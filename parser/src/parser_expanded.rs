// This file was generated by rustylr 1.0.3
//
// Input file: parser/src/parser.rs
// Output file: parser_expanded.rs
// ================================User Codes Begin================================
use crate::expression;
use crate::statement;
use crate::Expression;
use crate::IntType;
use crate::ParseError;
use crate::Span;
use crate::SpannedString;
use crate::Statement;
use lua_tokenizer::IntOrFloat;
use lua_tokenizer::Token;
use lua_tokenizer::TokenType;
// =================================User Codes End=================================
/*
====================================Grammar=====================================
Chunk -> Block
Block -> Statement* ReturnStatement?
Statement -> semicolon
Statement -> VarList equal ExpList1
Statement -> FunctionCall
Statement -> coloncolon ident coloncolon
Statement -> break_
Statement -> goto_ ident
Statement -> do_ Block end_
Statement -> while_ Exp do_ Block end_
Statement -> repeat_ Block until_ Exp
Statement -> if_ Exp then_ Block ElseIf* (else_, Block)? end_
Statement -> for_ ident equal Exp comma Exp (comma, Exp)? do_ Block end_
Statement -> for_ NameList in_ ExpList1 do_ Block end_
Statement -> function_ FuncName FuncBody
Statement -> local_ function_ ident FuncBody
Statement -> local_ AttNameList (equal, ExpList1)?
ElseIf -> elseif_ Exp then_ Block
ReturnStatement -> return_ ExpList0 semicolon?
Var -> ident
Var -> PrefixExp lbracket Exp rbracket
Var -> PrefixExp dot ident
PrefixExp -> Var
PrefixExp -> FunctionCall
PrefixExp -> lparen Exp rparen
FunctionCall -> PrefixExp Args
FunctionCall -> PrefixExp colon ident Args
Args -> lparen ExpList0 rparen
Args -> TableConstructor
Args -> string_literal
VarList -> VarList comma Var
VarList -> Var
ExpList1 -> ExpList1 comma Exp
ExpList1 -> Exp
ExpList0 -> ExpList1
ExpList0 ->
NameList -> NameList comma ident
NameList -> ident
AttName -> ident Attrib
AttNameList -> AttNameList comma AttName
AttNameList -> AttName
Attrib -> less ident greater
Attrib ->
Exp -> Exp12
Exp0 -> numeric_literal
Exp0 -> nil
Exp0 -> string_literal
Exp0 -> bool_
Exp0 -> dotdotdot
Exp0 -> FunctionDef
Exp0 -> PrefixExp
Exp0 -> TableConstructor
Exp1 -> Exp0 caret Exp1
Exp1 -> Exp0
Exp2 -> not_ Exp2
Exp2 -> hash Exp2
Exp2 -> minus Exp2
Exp2 -> plus Exp2
Exp2 -> tilde Exp2
Exp2 -> Exp1
Exp3 -> Exp3 asterisk Exp2
Exp3 -> Exp3 slash Exp2
Exp3 -> Exp3 slashslash Exp2
Exp3 -> Exp3 percent Exp2
Exp3 -> Exp2
Exp4 -> Exp4 plus Exp3
Exp4 -> Exp4 minus Exp3
Exp4 -> Exp3
Exp5 -> Exp4 dotdot Exp5
Exp5 -> Exp4
Exp6 -> Exp6 lessless Exp5
Exp6 -> Exp6 greatergreater Exp5
Exp6 -> Exp5
Exp7 -> Exp7 ampersand Exp6
Exp7 -> Exp6
Exp8 -> Exp8 tilde Exp7
Exp8 -> Exp7
Exp9 -> Exp9 pipe Exp8
Exp9 -> Exp8
Exp10 -> Exp10 less Exp9
Exp10 -> Exp10 lessequal Exp9
Exp10 -> Exp10 greater Exp9
Exp10 -> Exp10 greaterequal Exp9
Exp10 -> Exp10 tildeequal Exp9
Exp10 -> Exp10 equalequal Exp9
Exp10 -> Exp9
Exp11 -> Exp11 and_ Exp10
Exp11 -> Exp10
Exp12 -> Exp12 or_ Exp11
Exp12 -> Exp11
TableConstructor -> lbrace FieldList rbrace
FieldList1 -> FieldList1 FieldSep Field
FieldList1 -> Field
FieldList -> FieldList1 FieldSep?
FieldList ->
Field -> lbracket Exp rbracket equal Exp
Field -> ident equal Exp
Field -> Exp
FieldSep -> comma
FieldSep -> semicolon
FunctionDef -> function_ FuncBody
FuncBody -> lparen ParList? rparen Block end_
FuncName1 -> FuncName1 dot ident
FuncName1 -> ident
FuncName -> FuncName1 colon ident
FuncName -> FuncName1
ParList -> NameList (comma, dotdotdot)?
ParList -> dotdotdot
Statement+ -> Statement
Statement+ -> Statement+ Statement
Statement* -> Statement+
Statement* ->
ReturnStatement? -> ReturnStatement
ReturnStatement? ->
ElseIf+ -> ElseIf
ElseIf+ -> ElseIf+ ElseIf
ElseIf* -> ElseIf+
ElseIf* ->
(else_, Block) -> else_ Block
(else_, Block)? -> (else_, Block)
(else_, Block)? ->
(comma, Exp) -> comma Exp
(comma, Exp)? -> (comma, Exp)
(comma, Exp)? ->
(equal, ExpList1) -> equal ExpList1
(equal, ExpList1)? -> (equal, ExpList1)
(equal, ExpList1)? ->
semicolon? -> semicolon
semicolon? ->
FieldSep? -> FieldSep
FieldSep? ->
ParList? -> ParList
ParList? ->
(comma, dotdotdot) -> comma dotdotdot
(comma, dotdotdot)? -> (comma, dotdotdot)
(comma, dotdotdot)? ->
Augmented -> Chunk eof

*/
// =============================Generated Codes Begin==============================
#[doc = r" type alias for `Context`"]
#[allow(non_camel_case_types, dead_code)]
pub type ChunkContext = ::rusty_lr::glr::Context<ChunkNodeEnum>;
#[doc = r" type alias for CFG production rule"]
#[allow(non_camel_case_types, dead_code)]
pub type ChunkRule = ::rusty_lr::ProductionRule<Token, ChunkNonTerminals>;
#[doc = r" type alias for DFA state"]
#[allow(non_camel_case_types, dead_code)]
pub type ChunkState = ::rusty_lr::glr::State<Token, ChunkNonTerminals>;
#[doc = r" type alias for `InvalidTerminalError`"]
#[allow(non_camel_case_types, dead_code)]
pub type ChunkInvalidTerminalError =
    ::rusty_lr::glr::InvalidTerminalError<Token, ChunkNonTerminals, ParseError>;
#[doc = r" type alias for `MultiplePathError`"]
#[allow(non_camel_case_types, dead_code)]
pub type ChunkMultiplePathError = ::rusty_lr::glr::MultiplePathError<Token, ChunkNonTerminals>;
#[doc = r" An enum that represents non-terminal symbols"]
#[allow(non_camel_case_types)]
#[derive(
    Clone,
    Copy,
    std :: hash :: Hash,
    std :: cmp :: PartialEq,
    std :: cmp :: Eq,
    std :: cmp :: PartialOrd,
    std :: cmp :: Ord,
)]
pub enum ChunkNonTerminals {
    Chunk,
    Block,
    Statement,
    ElseIf,
    ReturnStatement,
    Var,
    PrefixExp,
    FunctionCall,
    Args,
    VarList,
    ExpList1,
    ExpList0,
    NameList,
    AttName,
    AttNameList,
    Attrib,
    Exp,
    Exp0,
    Exp1,
    Exp2,
    Exp3,
    Exp4,
    Exp5,
    Exp6,
    Exp7,
    Exp8,
    Exp9,
    Exp10,
    Exp11,
    Exp12,
    TableConstructor,
    FieldList1,
    FieldList,
    Field,
    FieldSep,
    FunctionDef,
    FuncBody,
    FuncName1,
    FuncName,
    ParList,
    _Statement_Plus40,
    _Statement_Star41,
    _ReturnStatement_Question42,
    _ElseIf_Plus43,
    _ElseIf_Star44,
    _Group45,
    __Group45_Question46,
    _Group47,
    __Group47_Question48,
    _Group49,
    __Group49_Question50,
    _semicolon_Question51,
    _FieldSep_Question52,
    _ParList_Question53,
    _Group54,
    __Group54_Question55,
    Augmented,
}
impl std::fmt::Display for ChunkNonTerminals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ChunkNonTerminals::Chunk => write!(f, "Chunk"),
            ChunkNonTerminals::Block => write!(f, "Block"),
            ChunkNonTerminals::Statement => write!(f, "Statement"),
            ChunkNonTerminals::ElseIf => write!(f, "ElseIf"),
            ChunkNonTerminals::ReturnStatement => write!(f, "ReturnStatement"),
            ChunkNonTerminals::Var => write!(f, "Var"),
            ChunkNonTerminals::PrefixExp => write!(f, "PrefixExp"),
            ChunkNonTerminals::FunctionCall => write!(f, "FunctionCall"),
            ChunkNonTerminals::Args => write!(f, "Args"),
            ChunkNonTerminals::VarList => write!(f, "VarList"),
            ChunkNonTerminals::ExpList1 => write!(f, "ExpList1"),
            ChunkNonTerminals::ExpList0 => write!(f, "ExpList0"),
            ChunkNonTerminals::NameList => write!(f, "NameList"),
            ChunkNonTerminals::AttName => write!(f, "AttName"),
            ChunkNonTerminals::AttNameList => write!(f, "AttNameList"),
            ChunkNonTerminals::Attrib => write!(f, "Attrib"),
            ChunkNonTerminals::Exp => write!(f, "Exp"),
            ChunkNonTerminals::Exp0 => write!(f, "Exp0"),
            ChunkNonTerminals::Exp1 => write!(f, "Exp1"),
            ChunkNonTerminals::Exp2 => write!(f, "Exp2"),
            ChunkNonTerminals::Exp3 => write!(f, "Exp3"),
            ChunkNonTerminals::Exp4 => write!(f, "Exp4"),
            ChunkNonTerminals::Exp5 => write!(f, "Exp5"),
            ChunkNonTerminals::Exp6 => write!(f, "Exp6"),
            ChunkNonTerminals::Exp7 => write!(f, "Exp7"),
            ChunkNonTerminals::Exp8 => write!(f, "Exp8"),
            ChunkNonTerminals::Exp9 => write!(f, "Exp9"),
            ChunkNonTerminals::Exp10 => write!(f, "Exp10"),
            ChunkNonTerminals::Exp11 => write!(f, "Exp11"),
            ChunkNonTerminals::Exp12 => write!(f, "Exp12"),
            ChunkNonTerminals::TableConstructor => write!(f, "TableConstructor"),
            ChunkNonTerminals::FieldList1 => write!(f, "FieldList1"),
            ChunkNonTerminals::FieldList => write!(f, "FieldList"),
            ChunkNonTerminals::Field => write!(f, "Field"),
            ChunkNonTerminals::FieldSep => write!(f, "FieldSep"),
            ChunkNonTerminals::FunctionDef => write!(f, "FunctionDef"),
            ChunkNonTerminals::FuncBody => write!(f, "FuncBody"),
            ChunkNonTerminals::FuncName1 => write!(f, "FuncName1"),
            ChunkNonTerminals::FuncName => write!(f, "FuncName"),
            ChunkNonTerminals::ParList => write!(f, "ParList"),
            ChunkNonTerminals::_Statement_Plus40 => write!(f, "Statement+"),
            ChunkNonTerminals::_Statement_Star41 => write!(f, "Statement*"),
            ChunkNonTerminals::_ReturnStatement_Question42 => write!(f, "ReturnStatement?"),
            ChunkNonTerminals::_ElseIf_Plus43 => write!(f, "ElseIf+"),
            ChunkNonTerminals::_ElseIf_Star44 => write!(f, "ElseIf*"),
            ChunkNonTerminals::_Group45 => write!(f, "(else_, Block)"),
            ChunkNonTerminals::__Group45_Question46 => write!(f, "(else_, Block)?"),
            ChunkNonTerminals::_Group47 => write!(f, "(comma, Exp)"),
            ChunkNonTerminals::__Group47_Question48 => write!(f, "(comma, Exp)?"),
            ChunkNonTerminals::_Group49 => write!(f, "(equal, ExpList1)"),
            ChunkNonTerminals::__Group49_Question50 => write!(f, "(equal, ExpList1)?"),
            ChunkNonTerminals::_semicolon_Question51 => write!(f, "semicolon?"),
            ChunkNonTerminals::_FieldSep_Question52 => write!(f, "FieldSep?"),
            ChunkNonTerminals::_ParList_Question53 => write!(f, "ParList?"),
            ChunkNonTerminals::_Group54 => write!(f, "(comma, dotdotdot)"),
            ChunkNonTerminals::__Group54_Question55 => write!(f, "(comma, dotdotdot)?"),
            ChunkNonTerminals::Augmented => write!(f, "Augmented"),
        }
    }
}
impl std::fmt::Debug for ChunkNonTerminals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ChunkNonTerminals::Chunk => write!(f, "Chunk"),
            ChunkNonTerminals::Block => write!(f, "Block"),
            ChunkNonTerminals::Statement => write!(f, "Statement"),
            ChunkNonTerminals::ElseIf => write!(f, "ElseIf"),
            ChunkNonTerminals::ReturnStatement => write!(f, "ReturnStatement"),
            ChunkNonTerminals::Var => write!(f, "Var"),
            ChunkNonTerminals::PrefixExp => write!(f, "PrefixExp"),
            ChunkNonTerminals::FunctionCall => write!(f, "FunctionCall"),
            ChunkNonTerminals::Args => write!(f, "Args"),
            ChunkNonTerminals::VarList => write!(f, "VarList"),
            ChunkNonTerminals::ExpList1 => write!(f, "ExpList1"),
            ChunkNonTerminals::ExpList0 => write!(f, "ExpList0"),
            ChunkNonTerminals::NameList => write!(f, "NameList"),
            ChunkNonTerminals::AttName => write!(f, "AttName"),
            ChunkNonTerminals::AttNameList => write!(f, "AttNameList"),
            ChunkNonTerminals::Attrib => write!(f, "Attrib"),
            ChunkNonTerminals::Exp => write!(f, "Exp"),
            ChunkNonTerminals::Exp0 => write!(f, "Exp0"),
            ChunkNonTerminals::Exp1 => write!(f, "Exp1"),
            ChunkNonTerminals::Exp2 => write!(f, "Exp2"),
            ChunkNonTerminals::Exp3 => write!(f, "Exp3"),
            ChunkNonTerminals::Exp4 => write!(f, "Exp4"),
            ChunkNonTerminals::Exp5 => write!(f, "Exp5"),
            ChunkNonTerminals::Exp6 => write!(f, "Exp6"),
            ChunkNonTerminals::Exp7 => write!(f, "Exp7"),
            ChunkNonTerminals::Exp8 => write!(f, "Exp8"),
            ChunkNonTerminals::Exp9 => write!(f, "Exp9"),
            ChunkNonTerminals::Exp10 => write!(f, "Exp10"),
            ChunkNonTerminals::Exp11 => write!(f, "Exp11"),
            ChunkNonTerminals::Exp12 => write!(f, "Exp12"),
            ChunkNonTerminals::TableConstructor => write!(f, "TableConstructor"),
            ChunkNonTerminals::FieldList1 => write!(f, "FieldList1"),
            ChunkNonTerminals::FieldList => write!(f, "FieldList"),
            ChunkNonTerminals::Field => write!(f, "Field"),
            ChunkNonTerminals::FieldSep => write!(f, "FieldSep"),
            ChunkNonTerminals::FunctionDef => write!(f, "FunctionDef"),
            ChunkNonTerminals::FuncBody => write!(f, "FuncBody"),
            ChunkNonTerminals::FuncName1 => write!(f, "FuncName1"),
            ChunkNonTerminals::FuncName => write!(f, "FuncName"),
            ChunkNonTerminals::ParList => write!(f, "ParList"),
            ChunkNonTerminals::_Statement_Plus40 => write!(f, "Statement+"),
            ChunkNonTerminals::_Statement_Star41 => write!(f, "Statement*"),
            ChunkNonTerminals::_ReturnStatement_Question42 => write!(f, "ReturnStatement?"),
            ChunkNonTerminals::_ElseIf_Plus43 => write!(f, "ElseIf+"),
            ChunkNonTerminals::_ElseIf_Star44 => write!(f, "ElseIf*"),
            ChunkNonTerminals::_Group45 => write!(f, "(else_, Block)"),
            ChunkNonTerminals::__Group45_Question46 => write!(f, "(else_, Block)?"),
            ChunkNonTerminals::_Group47 => write!(f, "(comma, Exp)"),
            ChunkNonTerminals::__Group47_Question48 => write!(f, "(comma, Exp)?"),
            ChunkNonTerminals::_Group49 => write!(f, "(equal, ExpList1)"),
            ChunkNonTerminals::__Group49_Question50 => write!(f, "(equal, ExpList1)?"),
            ChunkNonTerminals::_semicolon_Question51 => write!(f, "semicolon?"),
            ChunkNonTerminals::_FieldSep_Question52 => write!(f, "FieldSep?"),
            ChunkNonTerminals::_ParList_Question53 => write!(f, "ParList?"),
            ChunkNonTerminals::_Group54 => write!(f, "(comma, dotdotdot)"),
            ChunkNonTerminals::__Group54_Question55 => write!(f, "(comma, dotdotdot)?"),
            ChunkNonTerminals::Augmented => write!(f, "Augmented"),
        }
    }
}
#[doc = r" enum for each non-terminal and terminal symbol, that actually hold data"]
#[allow(unused_braces, unused_parens, non_snake_case, non_camel_case_types)]
#[derive(Clone)]
pub enum ChunkNodeEnum {
    NonTerminals,
    Terminals(Token),
    Variant2(statement::Block),
    Variant3(Statement),
    Variant4(statement::StmtElseIf),
    Variant5(statement::ReturnStatement),
    Variant6(Expression),
    Variant7(expression::ExprFunctionCall),
    Variant8(expression::FunctionCallArguments),
    Variant9(Vec<Expression>),
    Variant10(Vec<SpannedString>),
    Variant11(statement::AttName),
    Variant12(Vec<statement::AttName>),
    Variant13(Option<statement::Attrib>),
    Variant14(expression::ExprTable),
    Variant15(Vec<expression::TableConstructorFieldBuilder>),
    Variant16(expression::TableConstructorFieldBuilder),
    Variant17(expression::ExprFunction),
    Variant18(statement::FunctionName),
    Variant19(expression::ParameterList),
    Variant20(Vec<Statement>),
    Variant21(Option<statement::ReturnStatement>),
    Variant22(Vec<statement::StmtElseIf>),
    Variant23(Option<statement::Block>),
    Variant24(Option<Expression>),
    Variant25(Option<Vec<Expression>>),
    Variant26(Option<Token>),
    Variant27(Option<expression::ParameterList>),
}
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut,
    dead_code
)]
impl ChunkNodeEnum {
    fn reduce_Chunk_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Block = if let ChunkNodeEnum::Variant2(Block) = __rustylr_args.pop().unwrap() {
            Block
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant2(Block))
    }
    fn reduce_Block_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Statement =
            if let ChunkNodeEnum::Variant20(Statement) = __rustylr_args.pop().unwrap() {
                Statement
            } else {
                unreachable!()
            };
        let mut ReturnStatement =
            if let ChunkNodeEnum::Variant21(ReturnStatement) = __rustylr_args.pop().unwrap() {
                ReturnStatement
            } else {
                unreachable!()
            };
        Ok(ChunkNodeEnum::Variant2({
            let span0 = if let Some(first) = Statement.first() {
                first.span()
            } else {
                Span::new_none()
            };
            if let Some(ret) = ReturnStatement {
                let span1 = ret.span();
                let span = span0.merge_ordered(&span1);
                statement::Block::new(Statement, Some(ret), span)
            } else {
                let span1 = if let Some(last) = Statement.last() {
                    last.span()
                } else {
                    Span::new_none()
                };
                let span = span0.merge_ordered(&span1);
                statement::Block::new(Statement, None, span)
            }
        }))
    }
    fn reduce_Statement_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut semicolon =
            if let ChunkNodeEnum::Terminals(semicolon) = __rustylr_args.pop().unwrap() {
                semicolon
            } else {
                unreachable!()
            };
        Ok(ChunkNodeEnum::Variant3({
            Statement::None(statement::StmtNone::new(semicolon.span()))
        }))
    }
    fn reduce_Statement_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut VarList = if let ChunkNodeEnum::Variant9(VarList) = __rustylr_args.pop().unwrap() {
            VarList
        } else {
            unreachable!()
        };
        let mut equal = if let ChunkNodeEnum::Terminals(equal) = __rustylr_args.pop().unwrap() {
            equal
        } else {
            unreachable!()
        };
        let mut ExpList1 = if let ChunkNodeEnum::Variant9(ExpList1) = __rustylr_args.pop().unwrap()
        {
            ExpList1
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant3({
            let span = VarList
                .first()
                .unwrap()
                .span()
                .merge_ordered(&ExpList1.last().unwrap().span());
            let span_eq = equal.span();
            Statement::Assignment(statement::StmtAssignment::new(
                VarList, ExpList1, span, span_eq,
            ))
        }))
    }
    fn reduce_Statement_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut FunctionCall =
            if let ChunkNodeEnum::Variant7(FunctionCall) = __rustylr_args.pop().unwrap() {
                FunctionCall
            } else {
                unreachable!()
            };
        Ok(ChunkNodeEnum::Variant3({
            Statement::FunctionCall(FunctionCall)
        }))
    }
    fn reduce_Statement_3(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut c1 = if let ChunkNodeEnum::Terminals(c1) = __rustylr_args.pop().unwrap() {
            c1
        } else {
            unreachable!()
        };
        let mut ident = if let ChunkNodeEnum::Terminals(ident) = __rustylr_args.pop().unwrap() {
            ident
        } else {
            unreachable!()
        };
        let mut c2 = if let ChunkNodeEnum::Terminals(c2) = __rustylr_args.pop().unwrap() {
            c2
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant3({
            let span = c1.span().merge_ordered(&c2.span());
            Statement::Label(statement::StmtLabel::new(ident.into(), span))
        }))
    }
    fn reduce_Statement_4(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut break_ = if let ChunkNodeEnum::Terminals(break_) = __rustylr_args.pop().unwrap() {
            break_
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant3({
            Statement::Break(statement::StmtBreak::new(break_.span()))
        }))
    }
    fn reduce_Statement_5(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut goto_ = if let ChunkNodeEnum::Terminals(goto_) = __rustylr_args.pop().unwrap() {
            goto_
        } else {
            unreachable!()
        };
        let mut ident = if let ChunkNodeEnum::Terminals(ident) = __rustylr_args.pop().unwrap() {
            ident
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant3({
            let span = goto_.span().merge_ordered(&ident.span());
            Statement::Goto(statement::StmtGoto::new(ident.into(), span))
        }))
    }
    fn reduce_Statement_6(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut do_ = if let ChunkNodeEnum::Terminals(do_) = __rustylr_args.pop().unwrap() {
            do_
        } else {
            unreachable!()
        };
        let mut Block = if let ChunkNodeEnum::Variant2(Block) = __rustylr_args.pop().unwrap() {
            Block
        } else {
            unreachable!()
        };
        let mut end_ = if let ChunkNodeEnum::Terminals(end_) = __rustylr_args.pop().unwrap() {
            end_
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant3({
            let span = do_.span().merge_ordered(&end_.span());
            Statement::Do(statement::StmtDo::new(Block, span))
        }))
    }
    fn reduce_Statement_7(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut while_ = if let ChunkNodeEnum::Terminals(while_) = __rustylr_args.pop().unwrap() {
            while_
        } else {
            unreachable!()
        };
        let mut Exp = if let ChunkNodeEnum::Variant6(Exp) = __rustylr_args.pop().unwrap() {
            Exp
        } else {
            unreachable!()
        };
        __rustylr_args.pop();
        let mut Block = if let ChunkNodeEnum::Variant2(Block) = __rustylr_args.pop().unwrap() {
            Block
        } else {
            unreachable!()
        };
        let mut end_ = if let ChunkNodeEnum::Terminals(end_) = __rustylr_args.pop().unwrap() {
            end_
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant3({
            let span = while_.span().merge_ordered(&end_.span());
            Statement::While(statement::StmtWhile::new(Exp, Block, span))
        }))
    }
    fn reduce_Statement_8(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut repeat_ = if let ChunkNodeEnum::Terminals(repeat_) = __rustylr_args.pop().unwrap() {
            repeat_
        } else {
            unreachable!()
        };
        let mut Block = if let ChunkNodeEnum::Variant2(Block) = __rustylr_args.pop().unwrap() {
            Block
        } else {
            unreachable!()
        };
        __rustylr_args.pop();
        let mut Exp = if let ChunkNodeEnum::Variant6(Exp) = __rustylr_args.pop().unwrap() {
            Exp
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant3({
            let span = repeat_.span().merge_ordered(&Exp.span());
            Statement::Repeat(statement::StmtRepeat::new(Block, Exp, span))
        }))
    }
    fn reduce_Statement_9(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut if_ = if let ChunkNodeEnum::Terminals(if_) = __rustylr_args.pop().unwrap() {
            if_
        } else {
            unreachable!()
        };
        let mut Exp = if let ChunkNodeEnum::Variant6(Exp) = __rustylr_args.pop().unwrap() {
            Exp
        } else {
            unreachable!()
        };
        __rustylr_args.pop();
        let mut Block = if let ChunkNodeEnum::Variant2(Block) = __rustylr_args.pop().unwrap() {
            Block
        } else {
            unreachable!()
        };
        let mut elseifs = if let ChunkNodeEnum::Variant22(elseifs) = __rustylr_args.pop().unwrap() {
            elseifs
        } else {
            unreachable!()
        };
        let mut else_ = if let ChunkNodeEnum::Variant23(else_) = __rustylr_args.pop().unwrap() {
            else_
        } else {
            unreachable!()
        };
        let mut end_ = if let ChunkNodeEnum::Terminals(end_) = __rustylr_args.pop().unwrap() {
            end_
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant3({
            let span = if_.span().merge_ordered(&end_.span());
            Statement::If(statement::StmtIf::new(Exp, Block, elseifs, else_, span))
        }))
    }
    fn reduce_Statement_10(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut for_ = if let ChunkNodeEnum::Terminals(for_) = __rustylr_args.pop().unwrap() {
            for_
        } else {
            unreachable!()
        };
        let mut ident = if let ChunkNodeEnum::Terminals(ident) = __rustylr_args.pop().unwrap() {
            ident
        } else {
            unreachable!()
        };
        __rustylr_args.pop();
        let mut start = if let ChunkNodeEnum::Variant6(start) = __rustylr_args.pop().unwrap() {
            start
        } else {
            unreachable!()
        };
        __rustylr_args.pop();
        let mut end = if let ChunkNodeEnum::Variant6(end) = __rustylr_args.pop().unwrap() {
            end
        } else {
            unreachable!()
        };
        let mut step = if let ChunkNodeEnum::Variant24(step) = __rustylr_args.pop().unwrap() {
            step
        } else {
            unreachable!()
        };
        __rustylr_args.pop();
        let mut Block = if let ChunkNodeEnum::Variant2(Block) = __rustylr_args.pop().unwrap() {
            Block
        } else {
            unreachable!()
        };
        let mut end_ = if let ChunkNodeEnum::Terminals(end_) = __rustylr_args.pop().unwrap() {
            end_
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant3({
            let span = for_.span().merge_ordered(&end_.span());
            Statement::For(statement::StmtFor::new(
                ident.token_type.into_ident().unwrap(),
                start,
                end,
                step.unwrap_or_else(|| {
                    Expression::Numeric(expression::ExprNumeric::new(1.into(), Span::new_none()))
                }),
                Block,
                span,
            ))
        }))
    }
    fn reduce_Statement_11(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut for_ = if let ChunkNodeEnum::Terminals(for_) = __rustylr_args.pop().unwrap() {
            for_
        } else {
            unreachable!()
        };
        let mut NameList = if let ChunkNodeEnum::Variant10(NameList) = __rustylr_args.pop().unwrap()
        {
            NameList
        } else {
            unreachable!()
        };
        __rustylr_args.pop();
        let mut ExpList1 = if let ChunkNodeEnum::Variant9(ExpList1) = __rustylr_args.pop().unwrap()
        {
            ExpList1
        } else {
            unreachable!()
        };
        __rustylr_args.pop();
        let mut Block = if let ChunkNodeEnum::Variant2(Block) = __rustylr_args.pop().unwrap() {
            Block
        } else {
            unreachable!()
        };
        let mut end_ = if let ChunkNodeEnum::Terminals(end_) = __rustylr_args.pop().unwrap() {
            end_
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant3({
            let span = for_.span().merge_ordered(&end_.span());
            Statement::ForGeneric(statement::StmtForGeneric::new(
                NameList, ExpList1, Block, span,
            ))
        }))
    }
    fn reduce_Statement_12(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut function_ =
            if let ChunkNodeEnum::Terminals(function_) = __rustylr_args.pop().unwrap() {
                function_
            } else {
                unreachable!()
            };
        let mut FuncName = if let ChunkNodeEnum::Variant18(FuncName) = __rustylr_args.pop().unwrap()
        {
            FuncName
        } else {
            unreachable!()
        };
        let mut FuncBody = if let ChunkNodeEnum::Variant17(FuncBody) = __rustylr_args.pop().unwrap()
        {
            FuncBody
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant3({
            let span = function_.span().merge_ordered(&FuncBody.span());
            Statement::FunctionDefinition(statement::StmtFunctionDefinition::new(
                FuncName, FuncBody, span,
            ))
        }))
    }
    fn reduce_Statement_13(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut local_ = if let ChunkNodeEnum::Terminals(local_) = __rustylr_args.pop().unwrap() {
            local_
        } else {
            unreachable!()
        };
        __rustylr_args.pop();
        let mut ident = if let ChunkNodeEnum::Terminals(ident) = __rustylr_args.pop().unwrap() {
            ident
        } else {
            unreachable!()
        };
        let mut FuncBody = if let ChunkNodeEnum::Variant17(FuncBody) = __rustylr_args.pop().unwrap()
        {
            FuncBody
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant3({
            let span = local_.span().merge_ordered(&FuncBody.span());
            Statement::FunctionDefinitionLocal(statement::StmtFunctionDefinitionLocal::new(
                ident.into(),
                FuncBody,
                span,
            ))
        }))
    }
    fn reduce_Statement_14(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut local_ = if let ChunkNodeEnum::Terminals(local_) = __rustylr_args.pop().unwrap() {
            local_
        } else {
            unreachable!()
        };
        let mut AttNameList =
            if let ChunkNodeEnum::Variant12(AttNameList) = __rustylr_args.pop().unwrap() {
                AttNameList
            } else {
                unreachable!()
            };
        let mut rhs_list = if let ChunkNodeEnum::Variant25(rhs_list) = __rustylr_args.pop().unwrap()
        {
            rhs_list
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant3({
            let span0 = local_.span();
            if let Some(rhs) = rhs_list {
                let span = span0.merge_ordered(&rhs.last().unwrap().span());
                Statement::LocalDeclaration(statement::StmtLocalDeclaration::new(
                    AttNameList,
                    Some(rhs),
                    span,
                ))
            } else {
                let span = AttNameList.last().unwrap().span();
                Statement::LocalDeclaration(statement::StmtLocalDeclaration::new(
                    AttNameList,
                    None,
                    span,
                ))
            }
        }))
    }
    fn reduce_ElseIf_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut elseif_ = if let ChunkNodeEnum::Terminals(elseif_) = __rustylr_args.pop().unwrap() {
            elseif_
        } else {
            unreachable!()
        };
        let mut Exp = if let ChunkNodeEnum::Variant6(Exp) = __rustylr_args.pop().unwrap() {
            Exp
        } else {
            unreachable!()
        };
        let mut then_ = if let ChunkNodeEnum::Terminals(then_) = __rustylr_args.pop().unwrap() {
            then_
        } else {
            unreachable!()
        };
        let mut Block = if let ChunkNodeEnum::Variant2(Block) = __rustylr_args.pop().unwrap() {
            Block
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant4({
            let span = if Block.span().is_none() {
                elseif_.span().merge_ordered(&then_.span())
            } else {
                elseif_.span().merge_ordered(&Block.span())
            };
            statement::StmtElseIf::new(Exp, Block, span)
        }))
    }
    fn reduce_ReturnStatement_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut return_ = if let ChunkNodeEnum::Terminals(return_) = __rustylr_args.pop().unwrap() {
            return_
        } else {
            unreachable!()
        };
        let mut ExpList0 = if let ChunkNodeEnum::Variant9(ExpList0) = __rustylr_args.pop().unwrap()
        {
            ExpList0
        } else {
            unreachable!()
        };
        let mut semicolon =
            if let ChunkNodeEnum::Variant26(semicolon) = __rustylr_args.pop().unwrap() {
                semicolon
            } else {
                unreachable!()
            };
        Ok(ChunkNodeEnum::Variant5({
            let span0 = return_.span();
            let span = if let Some(last) = semicolon {
                span0.merge_ordered(&last.span())
            } else {
                if let Some(last) = ExpList0.last() {
                    span0.merge_ordered(&last.span())
                } else {
                    span0
                }
            };
            statement::ReturnStatement::new(ExpList0, span)
        }))
    }
    fn reduce_Var_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut ident = if let ChunkNodeEnum::Terminals(ident) = __rustylr_args.pop().unwrap() {
            ident
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({ Expression::Ident(ident.into()) }))
    }
    fn reduce_Var_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut PrefixExp =
            if let ChunkNodeEnum::Variant6(PrefixExp) = __rustylr_args.pop().unwrap() {
                PrefixExp
            } else {
                unreachable!()
            };
        __rustylr_args.pop();
        let mut Exp = if let ChunkNodeEnum::Variant6(Exp) = __rustylr_args.pop().unwrap() {
            Exp
        } else {
            unreachable!()
        };
        let mut rbracket = if let ChunkNodeEnum::Terminals(rbracket) = __rustylr_args.pop().unwrap()
        {
            rbracket
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = PrefixExp.span().merge_ordered(&rbracket.span());
            Expression::TableIndex(expression::ExprTableIndex::new(PrefixExp, Exp, span))
        }))
    }
    fn reduce_Var_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut PrefixExp =
            if let ChunkNodeEnum::Variant6(PrefixExp) = __rustylr_args.pop().unwrap() {
                PrefixExp
            } else {
                unreachable!()
            };
        __rustylr_args.pop();
        let mut ident = if let ChunkNodeEnum::Terminals(ident) = __rustylr_args.pop().unwrap() {
            ident
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = PrefixExp.span().merge_ordered(&ident.span());
            let member = expression::ExprString::from(ident);
            Expression::TableIndex(expression::ExprTableIndex::new(
                PrefixExp,
                Expression::String(member),
                span,
            ))
        }))
    }
    fn reduce_PrefixExp_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Var = if let ChunkNodeEnum::Variant6(Var) = __rustylr_args.pop().unwrap() {
            Var
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6(Var))
    }
    fn reduce_PrefixExp_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut FunctionCall =
            if let ChunkNodeEnum::Variant7(FunctionCall) = __rustylr_args.pop().unwrap() {
                FunctionCall
            } else {
                unreachable!()
            };
        Ok(ChunkNodeEnum::Variant6({
            Expression::FunctionCall(FunctionCall)
        }))
    }
    fn reduce_PrefixExp_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        __rustylr_args.pop();
        let mut Exp = if let ChunkNodeEnum::Variant6(Exp) = __rustylr_args.pop().unwrap() {
            Exp
        } else {
            unreachable!()
        };
        __rustylr_args.pop();
        Ok(ChunkNodeEnum::Variant6(Exp))
    }
    fn reduce_FunctionCall_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut PrefixExp =
            if let ChunkNodeEnum::Variant6(PrefixExp) = __rustylr_args.pop().unwrap() {
                PrefixExp
            } else {
                unreachable!()
            };
        let mut Args = if let ChunkNodeEnum::Variant8(Args) = __rustylr_args.pop().unwrap() {
            Args
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant7({
            let span = PrefixExp.span().merge_ordered(&Args.span());
            expression::ExprFunctionCall::new(PrefixExp, None, Args, span)
        }))
    }
    fn reduce_FunctionCall_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut PrefixExp =
            if let ChunkNodeEnum::Variant6(PrefixExp) = __rustylr_args.pop().unwrap() {
                PrefixExp
            } else {
                unreachable!()
            };
        __rustylr_args.pop();
        let mut ident = if let ChunkNodeEnum::Terminals(ident) = __rustylr_args.pop().unwrap() {
            ident
        } else {
            unreachable!()
        };
        let mut Args = if let ChunkNodeEnum::Variant8(Args) = __rustylr_args.pop().unwrap() {
            Args
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant7({
            let span = PrefixExp.span().merge_ordered(&Args.span());
            expression::ExprFunctionCall::new(PrefixExp, Some(ident.into()), Args, span)
        }))
    }
    fn reduce_Args_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut lparen = if let ChunkNodeEnum::Terminals(lparen) = __rustylr_args.pop().unwrap() {
            lparen
        } else {
            unreachable!()
        };
        let mut ExpList0 = if let ChunkNodeEnum::Variant9(ExpList0) = __rustylr_args.pop().unwrap()
        {
            ExpList0
        } else {
            unreachable!()
        };
        let mut rparen = if let ChunkNodeEnum::Terminals(rparen) = __rustylr_args.pop().unwrap() {
            rparen
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant8({
            let span = lparen.span().merge_ordered(&rparen.span());
            expression::FunctionCallArguments::new(ExpList0, span)
        }))
    }
    fn reduce_Args_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut TableConstructor =
            if let ChunkNodeEnum::Variant14(TableConstructor) = __rustylr_args.pop().unwrap() {
                TableConstructor
            } else {
                unreachable!()
            };
        Ok(ChunkNodeEnum::Variant8({
            let span = TableConstructor.span();
            let table_expr = Expression::Table(TableConstructor);
            let exprs = vec![table_expr];
            expression::FunctionCallArguments::new(exprs, span)
        }))
    }
    fn reduce_Args_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut string_literal =
            if let ChunkNodeEnum::Terminals(string_literal) = __rustylr_args.pop().unwrap() {
                string_literal
            } else {
                unreachable!()
            };
        Ok(ChunkNodeEnum::Variant8({
            let span = string_literal.span();
            let exprs = vec![Expression::String(string_literal.into())];
            expression::FunctionCallArguments::new(exprs, span)
        }))
    }
    fn reduce_VarList_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut VarList = if let ChunkNodeEnum::Variant9(VarList) = __rustylr_args.pop().unwrap() {
            VarList
        } else {
            unreachable!()
        };
        let mut comma = if let ChunkNodeEnum::Terminals(comma) = __rustylr_args.pop().unwrap() {
            comma
        } else {
            unreachable!()
        };
        let mut Var = if let ChunkNodeEnum::Variant6(Var) = __rustylr_args.pop().unwrap() {
            Var
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant9({
            VarList.push(Var);
            VarList
        }))
    }
    fn reduce_VarList_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Var = if let ChunkNodeEnum::Variant6(Var) = __rustylr_args.pop().unwrap() {
            Var
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant9({ vec![Var] }))
    }
    fn reduce_ExpList1_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut ExpList1 = if let ChunkNodeEnum::Variant9(ExpList1) = __rustylr_args.pop().unwrap()
        {
            ExpList1
        } else {
            unreachable!()
        };
        let mut comma = if let ChunkNodeEnum::Terminals(comma) = __rustylr_args.pop().unwrap() {
            comma
        } else {
            unreachable!()
        };
        let mut Exp = if let ChunkNodeEnum::Variant6(Exp) = __rustylr_args.pop().unwrap() {
            Exp
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant9({
            ExpList1.push(Exp);
            ExpList1
        }))
    }
    fn reduce_ExpList1_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp = if let ChunkNodeEnum::Variant6(Exp) = __rustylr_args.pop().unwrap() {
            Exp
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant9({ vec![Exp] }))
    }
    fn reduce_ExpList0_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut ExpList1 = if let ChunkNodeEnum::Variant9(ExpList1) = __rustylr_args.pop().unwrap()
        {
            ExpList1
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant9({ ExpList1 }))
    }
    fn reduce_ExpList0_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        Ok(ChunkNodeEnum::Variant9({ vec![] }))
    }
    fn reduce_NameList_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut NameList = if let ChunkNodeEnum::Variant10(NameList) = __rustylr_args.pop().unwrap()
        {
            NameList
        } else {
            unreachable!()
        };
        __rustylr_args.pop();
        let mut ident = if let ChunkNodeEnum::Terminals(ident) = __rustylr_args.pop().unwrap() {
            ident
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant10({
            NameList.push(ident.into());
            NameList
        }))
    }
    fn reduce_NameList_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut ident = if let ChunkNodeEnum::Terminals(ident) = __rustylr_args.pop().unwrap() {
            ident
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant10({ vec![ident.into()] }))
    }
    fn reduce_AttName_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut ident = if let ChunkNodeEnum::Terminals(ident) = __rustylr_args.pop().unwrap() {
            ident
        } else {
            unreachable!()
        };
        let mut Attrib = if let ChunkNodeEnum::Variant13(Attrib) = __rustylr_args.pop().unwrap() {
            Attrib
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant11({
            let span = ident.span();
            statement::AttName::new(ident.into(), Attrib, span)
        }))
    }
    fn reduce_AttNameList_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut AttNameList =
            if let ChunkNodeEnum::Variant12(AttNameList) = __rustylr_args.pop().unwrap() {
                AttNameList
            } else {
                unreachable!()
            };
        __rustylr_args.pop();
        let mut AttName = if let ChunkNodeEnum::Variant11(AttName) = __rustylr_args.pop().unwrap() {
            AttName
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant12({
            AttNameList.push(AttName);
            AttNameList
        }))
    }
    fn reduce_AttNameList_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut AttName = if let ChunkNodeEnum::Variant11(AttName) = __rustylr_args.pop().unwrap() {
            AttName
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant12({ vec![AttName] }))
    }
    fn reduce_Attrib_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        __rustylr_args.pop();
        let mut ident = if let ChunkNodeEnum::Terminals(ident) = __rustylr_args.pop().unwrap() {
            ident
        } else {
            unreachable!()
        };
        __rustylr_args.pop();
        Ok(ChunkNodeEnum::Variant13({
            let s: SpannedString = ident.into();
            match s.as_str() {
                "const" => Some(statement::Attrib::Const),
                "close" => Some(statement::Attrib::Close),
                _ => {
                    return Err(ParseError::UnknownAttribute(s));
                }
            }
        }))
    }
    fn reduce_Attrib_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        Ok(ChunkNodeEnum::Variant13({ None }))
    }
    fn reduce_Exp_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp12 = if let ChunkNodeEnum::Variant6(Exp12) = __rustylr_args.pop().unwrap() {
            Exp12
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6(Exp12))
    }
    fn reduce_Exp0_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut numeric_literal =
            if let ChunkNodeEnum::Terminals(numeric_literal) = __rustylr_args.pop().unwrap() {
                numeric_literal
            } else {
                unreachable!()
            };
        Ok(ChunkNodeEnum::Variant6({
            Expression::Numeric(numeric_literal.into())
        }))
    }
    fn reduce_Exp0_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut nil = if let ChunkNodeEnum::Terminals(nil) = __rustylr_args.pop().unwrap() {
            nil
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({ Expression::Nil(nil.into()) }))
    }
    fn reduce_Exp0_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut string_literal =
            if let ChunkNodeEnum::Terminals(string_literal) = __rustylr_args.pop().unwrap() {
                string_literal
            } else {
                unreachable!()
            };
        Ok(ChunkNodeEnum::Variant6({
            Expression::String(string_literal.into())
        }))
    }
    fn reduce_Exp0_3(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut bool_ = if let ChunkNodeEnum::Terminals(bool_) = __rustylr_args.pop().unwrap() {
            bool_
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({ Expression::Bool(bool_.into()) }))
    }
    fn reduce_Exp0_4(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut dotdotdot =
            if let ChunkNodeEnum::Terminals(dotdotdot) = __rustylr_args.pop().unwrap() {
                dotdotdot
            } else {
                unreachable!()
            };
        Ok(ChunkNodeEnum::Variant6({
            Expression::Variadic(dotdotdot.into())
        }))
    }
    fn reduce_Exp0_5(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut FunctionDef =
            if let ChunkNodeEnum::Variant17(FunctionDef) = __rustylr_args.pop().unwrap() {
                FunctionDef
            } else {
                unreachable!()
            };
        Ok(ChunkNodeEnum::Variant6({
            Expression::Function(FunctionDef)
        }))
    }
    fn reduce_Exp0_6(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut PrefixExp =
            if let ChunkNodeEnum::Variant6(PrefixExp) = __rustylr_args.pop().unwrap() {
                PrefixExp
            } else {
                unreachable!()
            };
        Ok(ChunkNodeEnum::Variant6(PrefixExp))
    }
    fn reduce_Exp0_7(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut TableConstructor =
            if let ChunkNodeEnum::Variant14(TableConstructor) = __rustylr_args.pop().unwrap() {
                TableConstructor
            } else {
                unreachable!()
            };
        Ok(ChunkNodeEnum::Variant6({
            Expression::Table(TableConstructor)
        }))
    }
    fn reduce_Exp1_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp0 = if let ChunkNodeEnum::Variant6(Exp0) = __rustylr_args.pop().unwrap() {
            Exp0
        } else {
            unreachable!()
        };
        let mut caret = if let ChunkNodeEnum::Terminals(caret) = __rustylr_args.pop().unwrap() {
            caret
        } else {
            unreachable!()
        };
        let mut Exp1 = if let ChunkNodeEnum::Variant6(Exp1) = __rustylr_args.pop().unwrap() {
            Exp1
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp0.span().merge_ordered(&Exp1.span());
            let span_op = caret.span();
            let binary_data = expression::ExprBinaryData::new(Exp0, Exp1, span, span_op);
            Expression::Binary(expression::ExprBinary::Pow(binary_data))
        }))
    }
    fn reduce_Exp1_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp0 = if let ChunkNodeEnum::Variant6(Exp0) = __rustylr_args.pop().unwrap() {
            Exp0
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6(Exp0))
    }
    fn reduce_Exp2_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut not_ = if let ChunkNodeEnum::Terminals(not_) = __rustylr_args.pop().unwrap() {
            not_
        } else {
            unreachable!()
        };
        let mut Exp2 = if let ChunkNodeEnum::Variant6(Exp2) = __rustylr_args.pop().unwrap() {
            Exp2
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = not_.span().merge_ordered(&Exp2.span());
            let span_op = not_.span();
            let unary_data = expression::ExprUnaryData::new(Exp2, span, span_op);
            Expression::Unary(expression::ExprUnary::LogicalNot(unary_data))
        }))
    }
    fn reduce_Exp2_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut hash = if let ChunkNodeEnum::Terminals(hash) = __rustylr_args.pop().unwrap() {
            hash
        } else {
            unreachable!()
        };
        let mut Exp2 = if let ChunkNodeEnum::Variant6(Exp2) = __rustylr_args.pop().unwrap() {
            Exp2
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = hash.span().merge_ordered(&Exp2.span());
            let span_op = hash.span();
            let unary_data = expression::ExprUnaryData::new(Exp2, span, span_op);
            Expression::Unary(expression::ExprUnary::Length(unary_data))
        }))
    }
    fn reduce_Exp2_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut minus = if let ChunkNodeEnum::Terminals(minus) = __rustylr_args.pop().unwrap() {
            minus
        } else {
            unreachable!()
        };
        let mut Exp2 = if let ChunkNodeEnum::Variant6(Exp2) = __rustylr_args.pop().unwrap() {
            Exp2
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = minus.span().merge_ordered(&Exp2.span());
            let span_op = minus.span();
            let unary_data = expression::ExprUnaryData::new(Exp2, span, span_op);
            Expression::Unary(expression::ExprUnary::Minus(unary_data))
        }))
    }
    fn reduce_Exp2_3(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut plus = if let ChunkNodeEnum::Terminals(plus) = __rustylr_args.pop().unwrap() {
            plus
        } else {
            unreachable!()
        };
        let mut Exp2 = if let ChunkNodeEnum::Variant6(Exp2) = __rustylr_args.pop().unwrap() {
            Exp2
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = plus.span().merge_ordered(&Exp2.span());
            let span_op = plus.span();
            let unary_data = expression::ExprUnaryData::new(Exp2, span, span_op);
            Expression::Unary(expression::ExprUnary::Plus(unary_data))
        }))
    }
    fn reduce_Exp2_4(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut tilde = if let ChunkNodeEnum::Terminals(tilde) = __rustylr_args.pop().unwrap() {
            tilde
        } else {
            unreachable!()
        };
        let mut Exp2 = if let ChunkNodeEnum::Variant6(Exp2) = __rustylr_args.pop().unwrap() {
            Exp2
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = tilde.span().merge_ordered(&Exp2.span());
            let span_op = tilde.span();
            let unary_data = expression::ExprUnaryData::new(Exp2, span, span_op);
            Expression::Unary(expression::ExprUnary::BitwiseNot(unary_data))
        }))
    }
    fn reduce_Exp2_5(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp1 = if let ChunkNodeEnum::Variant6(Exp1) = __rustylr_args.pop().unwrap() {
            Exp1
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6(Exp1))
    }
    fn reduce_Exp3_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp3 = if let ChunkNodeEnum::Variant6(Exp3) = __rustylr_args.pop().unwrap() {
            Exp3
        } else {
            unreachable!()
        };
        let mut asterisk = if let ChunkNodeEnum::Terminals(asterisk) = __rustylr_args.pop().unwrap()
        {
            asterisk
        } else {
            unreachable!()
        };
        let mut Exp2 = if let ChunkNodeEnum::Variant6(Exp2) = __rustylr_args.pop().unwrap() {
            Exp2
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp3.span().merge_ordered(&Exp2.span());
            let span_op = asterisk.span();
            let binary_data = expression::ExprBinaryData::new(Exp3, Exp2, span, span_op);
            Expression::Binary(expression::ExprBinary::Mul(binary_data))
        }))
    }
    fn reduce_Exp3_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp3 = if let ChunkNodeEnum::Variant6(Exp3) = __rustylr_args.pop().unwrap() {
            Exp3
        } else {
            unreachable!()
        };
        let mut slash = if let ChunkNodeEnum::Terminals(slash) = __rustylr_args.pop().unwrap() {
            slash
        } else {
            unreachable!()
        };
        let mut Exp2 = if let ChunkNodeEnum::Variant6(Exp2) = __rustylr_args.pop().unwrap() {
            Exp2
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp3.span().merge_ordered(&Exp2.span());
            let span_op = slash.span();
            let binary_data = expression::ExprBinaryData::new(Exp3, Exp2, span, span_op);
            Expression::Binary(expression::ExprBinary::Div(binary_data))
        }))
    }
    fn reduce_Exp3_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp3 = if let ChunkNodeEnum::Variant6(Exp3) = __rustylr_args.pop().unwrap() {
            Exp3
        } else {
            unreachable!()
        };
        let mut slashslash =
            if let ChunkNodeEnum::Terminals(slashslash) = __rustylr_args.pop().unwrap() {
                slashslash
            } else {
                unreachable!()
            };
        let mut Exp2 = if let ChunkNodeEnum::Variant6(Exp2) = __rustylr_args.pop().unwrap() {
            Exp2
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp3.span().merge_ordered(&Exp2.span());
            let span_op = slashslash.span();
            let binary_data = expression::ExprBinaryData::new(Exp3, Exp2, span, span_op);
            Expression::Binary(expression::ExprBinary::FloorDiv(binary_data))
        }))
    }
    fn reduce_Exp3_3(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp3 = if let ChunkNodeEnum::Variant6(Exp3) = __rustylr_args.pop().unwrap() {
            Exp3
        } else {
            unreachable!()
        };
        let mut percent = if let ChunkNodeEnum::Terminals(percent) = __rustylr_args.pop().unwrap() {
            percent
        } else {
            unreachable!()
        };
        let mut Exp2 = if let ChunkNodeEnum::Variant6(Exp2) = __rustylr_args.pop().unwrap() {
            Exp2
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp3.span().merge_ordered(&Exp2.span());
            let span_op = percent.span();
            let binary_data = expression::ExprBinaryData::new(Exp3, Exp2, span, span_op);
            Expression::Binary(expression::ExprBinary::Mod(binary_data))
        }))
    }
    fn reduce_Exp3_4(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp2 = if let ChunkNodeEnum::Variant6(Exp2) = __rustylr_args.pop().unwrap() {
            Exp2
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6(Exp2))
    }
    fn reduce_Exp4_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp4 = if let ChunkNodeEnum::Variant6(Exp4) = __rustylr_args.pop().unwrap() {
            Exp4
        } else {
            unreachable!()
        };
        let mut plus = if let ChunkNodeEnum::Terminals(plus) = __rustylr_args.pop().unwrap() {
            plus
        } else {
            unreachable!()
        };
        let mut Exp3 = if let ChunkNodeEnum::Variant6(Exp3) = __rustylr_args.pop().unwrap() {
            Exp3
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp4.span().merge_ordered(&Exp3.span());
            let span_op = plus.span();
            let binary_data = expression::ExprBinaryData::new(Exp4, Exp3, span, span_op);
            Expression::Binary(expression::ExprBinary::Add(binary_data))
        }))
    }
    fn reduce_Exp4_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp4 = if let ChunkNodeEnum::Variant6(Exp4) = __rustylr_args.pop().unwrap() {
            Exp4
        } else {
            unreachable!()
        };
        let mut minus = if let ChunkNodeEnum::Terminals(minus) = __rustylr_args.pop().unwrap() {
            minus
        } else {
            unreachable!()
        };
        let mut Exp3 = if let ChunkNodeEnum::Variant6(Exp3) = __rustylr_args.pop().unwrap() {
            Exp3
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp4.span().merge_ordered(&Exp3.span());
            let span_op = minus.span();
            let binary_data = expression::ExprBinaryData::new(Exp4, Exp3, span, span_op);
            Expression::Binary(expression::ExprBinary::Sub(binary_data))
        }))
    }
    fn reduce_Exp4_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp3 = if let ChunkNodeEnum::Variant6(Exp3) = __rustylr_args.pop().unwrap() {
            Exp3
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6(Exp3))
    }
    fn reduce_Exp5_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp4 = if let ChunkNodeEnum::Variant6(Exp4) = __rustylr_args.pop().unwrap() {
            Exp4
        } else {
            unreachable!()
        };
        let mut dotdot = if let ChunkNodeEnum::Terminals(dotdot) = __rustylr_args.pop().unwrap() {
            dotdot
        } else {
            unreachable!()
        };
        let mut Exp5 = if let ChunkNodeEnum::Variant6(Exp5) = __rustylr_args.pop().unwrap() {
            Exp5
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp4.span().merge_ordered(&Exp5.span());
            let span_op = dotdot.span();
            let binary_data = expression::ExprBinaryData::new(Exp4, Exp5, span, span_op);
            Expression::Binary(expression::ExprBinary::Concat(binary_data))
        }))
    }
    fn reduce_Exp5_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp4 = if let ChunkNodeEnum::Variant6(Exp4) = __rustylr_args.pop().unwrap() {
            Exp4
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6(Exp4))
    }
    fn reduce_Exp6_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp6 = if let ChunkNodeEnum::Variant6(Exp6) = __rustylr_args.pop().unwrap() {
            Exp6
        } else {
            unreachable!()
        };
        let mut lessless = if let ChunkNodeEnum::Terminals(lessless) = __rustylr_args.pop().unwrap()
        {
            lessless
        } else {
            unreachable!()
        };
        let mut Exp5 = if let ChunkNodeEnum::Variant6(Exp5) = __rustylr_args.pop().unwrap() {
            Exp5
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp6.span().merge_ordered(&Exp5.span());
            let span_op = lessless.span();
            let binary_data = expression::ExprBinaryData::new(Exp6, Exp5, span, span_op);
            Expression::Binary(expression::ExprBinary::ShiftLeft(binary_data))
        }))
    }
    fn reduce_Exp6_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp6 = if let ChunkNodeEnum::Variant6(Exp6) = __rustylr_args.pop().unwrap() {
            Exp6
        } else {
            unreachable!()
        };
        let mut greatergreater =
            if let ChunkNodeEnum::Terminals(greatergreater) = __rustylr_args.pop().unwrap() {
                greatergreater
            } else {
                unreachable!()
            };
        let mut Exp5 = if let ChunkNodeEnum::Variant6(Exp5) = __rustylr_args.pop().unwrap() {
            Exp5
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp6.span().merge_ordered(&Exp5.span());
            let span_op = greatergreater.span();
            let binary_data = expression::ExprBinaryData::new(Exp6, Exp5, span, span_op);
            Expression::Binary(expression::ExprBinary::ShiftRight(binary_data))
        }))
    }
    fn reduce_Exp6_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp5 = if let ChunkNodeEnum::Variant6(Exp5) = __rustylr_args.pop().unwrap() {
            Exp5
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6(Exp5))
    }
    fn reduce_Exp7_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp7 = if let ChunkNodeEnum::Variant6(Exp7) = __rustylr_args.pop().unwrap() {
            Exp7
        } else {
            unreachable!()
        };
        let mut ampersand =
            if let ChunkNodeEnum::Terminals(ampersand) = __rustylr_args.pop().unwrap() {
                ampersand
            } else {
                unreachable!()
            };
        let mut Exp6 = if let ChunkNodeEnum::Variant6(Exp6) = __rustylr_args.pop().unwrap() {
            Exp6
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp7.span().merge_ordered(&Exp6.span());
            let span_op = ampersand.span();
            let binary_data = expression::ExprBinaryData::new(Exp7, Exp6, span, span_op);
            Expression::Binary(expression::ExprBinary::BitwiseAnd(binary_data))
        }))
    }
    fn reduce_Exp7_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp6 = if let ChunkNodeEnum::Variant6(Exp6) = __rustylr_args.pop().unwrap() {
            Exp6
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6(Exp6))
    }
    fn reduce_Exp8_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp8 = if let ChunkNodeEnum::Variant6(Exp8) = __rustylr_args.pop().unwrap() {
            Exp8
        } else {
            unreachable!()
        };
        let mut tilde = if let ChunkNodeEnum::Terminals(tilde) = __rustylr_args.pop().unwrap() {
            tilde
        } else {
            unreachable!()
        };
        let mut Exp7 = if let ChunkNodeEnum::Variant6(Exp7) = __rustylr_args.pop().unwrap() {
            Exp7
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp8.span().merge_ordered(&Exp7.span());
            let span_op = tilde.span();
            let binary_data = expression::ExprBinaryData::new(Exp8, Exp7, span, span_op);
            Expression::Binary(expression::ExprBinary::BitwiseXor(binary_data))
        }))
    }
    fn reduce_Exp8_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp7 = if let ChunkNodeEnum::Variant6(Exp7) = __rustylr_args.pop().unwrap() {
            Exp7
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6(Exp7))
    }
    fn reduce_Exp9_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp9 = if let ChunkNodeEnum::Variant6(Exp9) = __rustylr_args.pop().unwrap() {
            Exp9
        } else {
            unreachable!()
        };
        let mut pipe = if let ChunkNodeEnum::Terminals(pipe) = __rustylr_args.pop().unwrap() {
            pipe
        } else {
            unreachable!()
        };
        let mut Exp8 = if let ChunkNodeEnum::Variant6(Exp8) = __rustylr_args.pop().unwrap() {
            Exp8
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp9.span().merge_ordered(&Exp8.span());
            let span_op = pipe.span();
            let binary_data = expression::ExprBinaryData::new(Exp9, Exp8, span, span_op);
            Expression::Binary(expression::ExprBinary::BitwiseOr(binary_data))
        }))
    }
    fn reduce_Exp9_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp8 = if let ChunkNodeEnum::Variant6(Exp8) = __rustylr_args.pop().unwrap() {
            Exp8
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6(Exp8))
    }
    fn reduce_Exp10_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp10 = if let ChunkNodeEnum::Variant6(Exp10) = __rustylr_args.pop().unwrap() {
            Exp10
        } else {
            unreachable!()
        };
        let mut less = if let ChunkNodeEnum::Terminals(less) = __rustylr_args.pop().unwrap() {
            less
        } else {
            unreachable!()
        };
        let mut Exp9 = if let ChunkNodeEnum::Variant6(Exp9) = __rustylr_args.pop().unwrap() {
            Exp9
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp10.span().merge_ordered(&Exp9.span());
            let span_op = less.span();
            let binary_data = expression::ExprBinaryData::new(Exp10, Exp9, span, span_op);
            Expression::Binary(expression::ExprBinary::LessThan(binary_data))
        }))
    }
    fn reduce_Exp10_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp10 = if let ChunkNodeEnum::Variant6(Exp10) = __rustylr_args.pop().unwrap() {
            Exp10
        } else {
            unreachable!()
        };
        let mut lessequal =
            if let ChunkNodeEnum::Terminals(lessequal) = __rustylr_args.pop().unwrap() {
                lessequal
            } else {
                unreachable!()
            };
        let mut Exp9 = if let ChunkNodeEnum::Variant6(Exp9) = __rustylr_args.pop().unwrap() {
            Exp9
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp10.span().merge_ordered(&Exp9.span());
            let span_op = lessequal.span();
            let binary_data = expression::ExprBinaryData::new(Exp10, Exp9, span, span_op);
            Expression::Binary(expression::ExprBinary::LessEqual(binary_data))
        }))
    }
    fn reduce_Exp10_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp10 = if let ChunkNodeEnum::Variant6(Exp10) = __rustylr_args.pop().unwrap() {
            Exp10
        } else {
            unreachable!()
        };
        let mut greater = if let ChunkNodeEnum::Terminals(greater) = __rustylr_args.pop().unwrap() {
            greater
        } else {
            unreachable!()
        };
        let mut Exp9 = if let ChunkNodeEnum::Variant6(Exp9) = __rustylr_args.pop().unwrap() {
            Exp9
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp10.span().merge_ordered(&Exp9.span());
            let span_op = greater.span();
            let binary_data = expression::ExprBinaryData::new(Exp10, Exp9, span, span_op);
            Expression::Binary(expression::ExprBinary::GreaterThan(binary_data))
        }))
    }
    fn reduce_Exp10_3(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp10 = if let ChunkNodeEnum::Variant6(Exp10) = __rustylr_args.pop().unwrap() {
            Exp10
        } else {
            unreachable!()
        };
        let mut greaterequal =
            if let ChunkNodeEnum::Terminals(greaterequal) = __rustylr_args.pop().unwrap() {
                greaterequal
            } else {
                unreachable!()
            };
        let mut Exp9 = if let ChunkNodeEnum::Variant6(Exp9) = __rustylr_args.pop().unwrap() {
            Exp9
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp10.span().merge_ordered(&Exp9.span());
            let span_op = greaterequal.span();
            let binary_data = expression::ExprBinaryData::new(Exp10, Exp9, span, span_op);
            Expression::Binary(expression::ExprBinary::GreaterEqual(binary_data))
        }))
    }
    fn reduce_Exp10_4(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp10 = if let ChunkNodeEnum::Variant6(Exp10) = __rustylr_args.pop().unwrap() {
            Exp10
        } else {
            unreachable!()
        };
        let mut tildeequal =
            if let ChunkNodeEnum::Terminals(tildeequal) = __rustylr_args.pop().unwrap() {
                tildeequal
            } else {
                unreachable!()
            };
        let mut Exp9 = if let ChunkNodeEnum::Variant6(Exp9) = __rustylr_args.pop().unwrap() {
            Exp9
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp10.span().merge_ordered(&Exp9.span());
            let span_op = tildeequal.span();
            let binary_data = expression::ExprBinaryData::new(Exp10, Exp9, span, span_op);
            Expression::Binary(expression::ExprBinary::NotEqual(binary_data))
        }))
    }
    fn reduce_Exp10_5(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp10 = if let ChunkNodeEnum::Variant6(Exp10) = __rustylr_args.pop().unwrap() {
            Exp10
        } else {
            unreachable!()
        };
        let mut equalequal =
            if let ChunkNodeEnum::Terminals(equalequal) = __rustylr_args.pop().unwrap() {
                equalequal
            } else {
                unreachable!()
            };
        let mut Exp9 = if let ChunkNodeEnum::Variant6(Exp9) = __rustylr_args.pop().unwrap() {
            Exp9
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp10.span().merge_ordered(&Exp9.span());
            let span_op = equalequal.span();
            let binary_data = expression::ExprBinaryData::new(Exp10, Exp9, span, span_op);
            Expression::Binary(expression::ExprBinary::Equal(binary_data))
        }))
    }
    fn reduce_Exp10_6(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp9 = if let ChunkNodeEnum::Variant6(Exp9) = __rustylr_args.pop().unwrap() {
            Exp9
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6(Exp9))
    }
    fn reduce_Exp11_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp11 = if let ChunkNodeEnum::Variant6(Exp11) = __rustylr_args.pop().unwrap() {
            Exp11
        } else {
            unreachable!()
        };
        let mut and_ = if let ChunkNodeEnum::Terminals(and_) = __rustylr_args.pop().unwrap() {
            and_
        } else {
            unreachable!()
        };
        let mut Exp10 = if let ChunkNodeEnum::Variant6(Exp10) = __rustylr_args.pop().unwrap() {
            Exp10
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp11.span().merge_ordered(&Exp10.span());
            let span_op = and_.span();
            let binary_data = expression::ExprBinaryData::new(Exp11, Exp10, span, span_op);
            Expression::Binary(expression::ExprBinary::LogicalAnd(binary_data))
        }))
    }
    fn reduce_Exp11_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp10 = if let ChunkNodeEnum::Variant6(Exp10) = __rustylr_args.pop().unwrap() {
            Exp10
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6(Exp10))
    }
    fn reduce_Exp12_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp12 = if let ChunkNodeEnum::Variant6(Exp12) = __rustylr_args.pop().unwrap() {
            Exp12
        } else {
            unreachable!()
        };
        let mut or_ = if let ChunkNodeEnum::Terminals(or_) = __rustylr_args.pop().unwrap() {
            or_
        } else {
            unreachable!()
        };
        let mut Exp11 = if let ChunkNodeEnum::Variant6(Exp11) = __rustylr_args.pop().unwrap() {
            Exp11
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6({
            let span = Exp12.span().merge_ordered(&Exp11.span());
            let span_op = or_.span();
            let binary_data = expression::ExprBinaryData::new(Exp12, Exp11, span, span_op);
            Expression::Binary(expression::ExprBinary::LogicalOr(binary_data))
        }))
    }
    fn reduce_Exp12_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp11 = if let ChunkNodeEnum::Variant6(Exp11) = __rustylr_args.pop().unwrap() {
            Exp11
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant6(Exp11))
    }
    fn reduce_TableConstructor_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut lbrace = if let ChunkNodeEnum::Terminals(lbrace) = __rustylr_args.pop().unwrap() {
            lbrace
        } else {
            unreachable!()
        };
        let mut FieldList =
            if let ChunkNodeEnum::Variant15(FieldList) = __rustylr_args.pop().unwrap() {
                FieldList
            } else {
                unreachable!()
            };
        let mut rbrace = if let ChunkNodeEnum::Terminals(rbrace) = __rustylr_args.pop().unwrap() {
            rbrace
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant14({
            let span = lbrace.span().merge_ordered(&rbrace.span());
            let mut table = expression::ExprTable::new(span);
            let mut consecutive: IntType = 1;
            for field in FieldList.into_iter() {
                match field {
                    expression::TableConstructorFieldBuilder::KeyValue(k, v) => {
                        let span = k.span().merge_ordered(&v.span());
                        table.fields.push(expression::TableField::new(k, v, span));
                    }
                    expression::TableConstructorFieldBuilder::NameValue(name, v) => {
                        let span = name.span().merge_ordered(&v.span());
                        table.fields.push(expression::TableField::new(
                            Expression::String(name.into()),
                            v,
                            span,
                        ));
                    }
                    expression::TableConstructorFieldBuilder::Value(v) => {
                        let idx = consecutive;
                        consecutive += 1;
                        let span = v.span();
                        table.fields.push(expression::TableField::new(
                            Expression::Numeric(expression::ExprNumeric::new(
                                idx.into(),
                                Span::new_none(),
                            )),
                            v,
                            span,
                        ));
                    }
                }
            }
            table
        }))
    }
    fn reduce_FieldList1_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut FieldList1 =
            if let ChunkNodeEnum::Variant15(FieldList1) = __rustylr_args.pop().unwrap() {
                FieldList1
            } else {
                unreachable!()
            };
        __rustylr_args.pop();
        let mut Field = if let ChunkNodeEnum::Variant16(Field) = __rustylr_args.pop().unwrap() {
            Field
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant15({
            FieldList1.push(Field);
            FieldList1
        }))
    }
    fn reduce_FieldList1_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Field = if let ChunkNodeEnum::Variant16(Field) = __rustylr_args.pop().unwrap() {
            Field
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant15({ vec![Field] }))
    }
    fn reduce_FieldList_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut FieldList1 =
            if let ChunkNodeEnum::Variant15(FieldList1) = __rustylr_args.pop().unwrap() {
                FieldList1
            } else {
                unreachable!()
            };
        __rustylr_args.pop();
        Ok(ChunkNodeEnum::Variant15({ FieldList1 }))
    }
    fn reduce_FieldList_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        Ok(ChunkNodeEnum::Variant15({ vec![] }))
    }
    fn reduce_Field_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        __rustylr_args.pop();
        let mut k = if let ChunkNodeEnum::Variant6(k) = __rustylr_args.pop().unwrap() {
            k
        } else {
            unreachable!()
        };
        __rustylr_args.pop();
        __rustylr_args.pop();
        let mut v = if let ChunkNodeEnum::Variant6(v) = __rustylr_args.pop().unwrap() {
            v
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant16({
            expression::TableConstructorFieldBuilder::KeyValue(k, v)
        }))
    }
    fn reduce_Field_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut ident = if let ChunkNodeEnum::Terminals(ident) = __rustylr_args.pop().unwrap() {
            ident
        } else {
            unreachable!()
        };
        __rustylr_args.pop();
        let mut Exp = if let ChunkNodeEnum::Variant6(Exp) = __rustylr_args.pop().unwrap() {
            Exp
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant16({
            expression::TableConstructorFieldBuilder::NameValue(ident.into(), Exp)
        }))
    }
    fn reduce_Field_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Exp = if let ChunkNodeEnum::Variant6(Exp) = __rustylr_args.pop().unwrap() {
            Exp
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant16({
            expression::TableConstructorFieldBuilder::Value(Exp)
        }))
    }
    fn reduce_FieldSep_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        __rustylr_args.clear();
        Ok(ChunkNodeEnum::NonTerminals)
    }
    fn reduce_FieldSep_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        __rustylr_args.clear();
        Ok(ChunkNodeEnum::NonTerminals)
    }
    fn reduce_FunctionDef_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut function_ =
            if let ChunkNodeEnum::Terminals(function_) = __rustylr_args.pop().unwrap() {
                function_
            } else {
                unreachable!()
            };
        let mut FuncBody = if let ChunkNodeEnum::Variant17(FuncBody) = __rustylr_args.pop().unwrap()
        {
            FuncBody
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant17({
            let span = function_.span().merge_ordered(&FuncBody.span());
            FuncBody.span = span;
            FuncBody
        }))
    }
    fn reduce_FuncBody_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut lparen = if let ChunkNodeEnum::Terminals(lparen) = __rustylr_args.pop().unwrap() {
            lparen
        } else {
            unreachable!()
        };
        let mut ParList = if let ChunkNodeEnum::Variant27(ParList) = __rustylr_args.pop().unwrap() {
            ParList
        } else {
            unreachable!()
        };
        __rustylr_args.pop();
        let mut Block = if let ChunkNodeEnum::Variant2(Block) = __rustylr_args.pop().unwrap() {
            Block
        } else {
            unreachable!()
        };
        let mut end_ = if let ChunkNodeEnum::Terminals(end_) = __rustylr_args.pop().unwrap() {
            end_
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant17({
            let span = lparen.span().merge_ordered(&end_.span());
            expression::ExprFunction::new(ParList, Block, span)
        }))
    }
    fn reduce_FuncName1_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut FuncName1 =
            if let ChunkNodeEnum::Variant10(FuncName1) = __rustylr_args.pop().unwrap() {
                FuncName1
            } else {
                unreachable!()
            };
        let mut dot = if let ChunkNodeEnum::Terminals(dot) = __rustylr_args.pop().unwrap() {
            dot
        } else {
            unreachable!()
        };
        let mut ident = if let ChunkNodeEnum::Terminals(ident) = __rustylr_args.pop().unwrap() {
            ident
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant10({
            FuncName1.push(ident.into());
            FuncName1
        }))
    }
    fn reduce_FuncName1_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut ident = if let ChunkNodeEnum::Terminals(ident) = __rustylr_args.pop().unwrap() {
            ident
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant10({ vec![ident.into()] }))
    }
    fn reduce_FuncName_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut FuncName1 =
            if let ChunkNodeEnum::Variant10(FuncName1) = __rustylr_args.pop().unwrap() {
                FuncName1
            } else {
                unreachable!()
            };
        __rustylr_args.pop();
        let mut ident = if let ChunkNodeEnum::Terminals(ident) = __rustylr_args.pop().unwrap() {
            ident
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant18({
            let span = FuncName1
                .first()
                .unwrap()
                .span()
                .merge_ordered(&ident.span());
            statement::FunctionName::new(FuncName1, Some(ident.into()), span)
        }))
    }
    fn reduce_FuncName_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut FuncName1 =
            if let ChunkNodeEnum::Variant10(FuncName1) = __rustylr_args.pop().unwrap() {
                FuncName1
            } else {
                unreachable!()
            };
        Ok(ChunkNodeEnum::Variant18({
            let span = FuncName1
                .first()
                .unwrap()
                .span()
                .merge_ordered(&FuncName1.last().unwrap().span());
            statement::FunctionName::new(FuncName1, None, span)
        }))
    }
    fn reduce_ParList_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut NameList = if let ChunkNodeEnum::Variant10(NameList) = __rustylr_args.pop().unwrap()
        {
            NameList
        } else {
            unreachable!()
        };
        let mut var = if let ChunkNodeEnum::Variant26(var) = __rustylr_args.pop().unwrap() {
            var
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant19({
            if let Some(var) = var {
                let span = NameList.first().unwrap().span().merge_ordered(&var.span());
                expression::ParameterList::new(NameList, true, span)
            } else {
                let span = NameList.first().unwrap().span();
                expression::ParameterList::new(NameList, false, span)
            }
        }))
    }
    fn reduce_ParList_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut dotdotdot =
            if let ChunkNodeEnum::Terminals(dotdotdot) = __rustylr_args.pop().unwrap() {
                dotdotdot
            } else {
                unreachable!()
            };
        Ok(ChunkNodeEnum::Variant19({
            expression::ParameterList::new(Vec::new(), true, dotdotdot.span())
        }))
    }
    fn reduce__Statement_Plus40_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut A = if let ChunkNodeEnum::Variant3(A) = __rustylr_args.pop().unwrap() {
            A
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant20({ vec![A] }))
    }
    fn reduce__Statement_Plus40_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Ap = if let ChunkNodeEnum::Variant20(Ap) = __rustylr_args.pop().unwrap() {
            Ap
        } else {
            unreachable!()
        };
        let mut A = if let ChunkNodeEnum::Variant3(A) = __rustylr_args.pop().unwrap() {
            A
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant20({
            Ap.push(A);
            Ap
        }))
    }
    fn reduce__Statement_Star41_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Ap = if let ChunkNodeEnum::Variant20(Ap) = __rustylr_args.pop().unwrap() {
            Ap
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant20({ Ap }))
    }
    fn reduce__Statement_Star41_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        Ok(ChunkNodeEnum::Variant20({ vec![] }))
    }
    fn reduce__ReturnStatement_Question42_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut A = if let ChunkNodeEnum::Variant5(A) = __rustylr_args.pop().unwrap() {
            A
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant21({ Some(A) }))
    }
    fn reduce__ReturnStatement_Question42_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        Ok(ChunkNodeEnum::Variant21({ None }))
    }
    fn reduce__ElseIf_Plus43_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut A = if let ChunkNodeEnum::Variant4(A) = __rustylr_args.pop().unwrap() {
            A
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant22({ vec![A] }))
    }
    fn reduce__ElseIf_Plus43_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Ap = if let ChunkNodeEnum::Variant22(Ap) = __rustylr_args.pop().unwrap() {
            Ap
        } else {
            unreachable!()
        };
        let mut A = if let ChunkNodeEnum::Variant4(A) = __rustylr_args.pop().unwrap() {
            A
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant22({
            Ap.push(A);
            Ap
        }))
    }
    fn reduce__ElseIf_Star44_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut Ap = if let ChunkNodeEnum::Variant22(Ap) = __rustylr_args.pop().unwrap() {
            Ap
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant22({ Ap }))
    }
    fn reduce__ElseIf_Star44_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        Ok(ChunkNodeEnum::Variant22({ vec![] }))
    }
    fn reduce__Group45_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        __rustylr_args.pop();
        let mut __rustylr_group_elem1 =
            if let ChunkNodeEnum::Variant2(__rustylr_group_elem1) = __rustylr_args.pop().unwrap() {
                __rustylr_group_elem1
            } else {
                unreachable!()
            };
        Ok(ChunkNodeEnum::Variant2(__rustylr_group_elem1))
    }
    fn reduce___Group45_Question46_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut A = if let ChunkNodeEnum::Variant2(A) = __rustylr_args.pop().unwrap() {
            A
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant23({ Some(A) }))
    }
    fn reduce___Group45_Question46_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        Ok(ChunkNodeEnum::Variant23({ None }))
    }
    fn reduce__Group47_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        __rustylr_args.pop();
        let mut __rustylr_group_elem1 =
            if let ChunkNodeEnum::Variant6(__rustylr_group_elem1) = __rustylr_args.pop().unwrap() {
                __rustylr_group_elem1
            } else {
                unreachable!()
            };
        Ok(ChunkNodeEnum::Variant6(__rustylr_group_elem1))
    }
    fn reduce___Group47_Question48_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut A = if let ChunkNodeEnum::Variant6(A) = __rustylr_args.pop().unwrap() {
            A
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant24({ Some(A) }))
    }
    fn reduce___Group47_Question48_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        Ok(ChunkNodeEnum::Variant24({ None }))
    }
    fn reduce__Group49_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        __rustylr_args.pop();
        let mut __rustylr_group_elem1 =
            if let ChunkNodeEnum::Variant9(__rustylr_group_elem1) = __rustylr_args.pop().unwrap() {
                __rustylr_group_elem1
            } else {
                unreachable!()
            };
        Ok(ChunkNodeEnum::Variant9(__rustylr_group_elem1))
    }
    fn reduce___Group49_Question50_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut A = if let ChunkNodeEnum::Variant9(A) = __rustylr_args.pop().unwrap() {
            A
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant25({ Some(A) }))
    }
    fn reduce___Group49_Question50_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        Ok(ChunkNodeEnum::Variant25({ None }))
    }
    fn reduce__semicolon_Question51_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut A = if let ChunkNodeEnum::Terminals(A) = __rustylr_args.pop().unwrap() {
            A
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant26({ Some(A) }))
    }
    fn reduce__semicolon_Question51_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        Ok(ChunkNodeEnum::Variant26({ None }))
    }
    fn reduce__FieldSep_Question52_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        __rustylr_args.clear();
        Ok(ChunkNodeEnum::NonTerminals)
    }
    fn reduce__FieldSep_Question52_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        __rustylr_args.clear();
        Ok(ChunkNodeEnum::NonTerminals)
    }
    fn reduce__ParList_Question53_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut A = if let ChunkNodeEnum::Variant19(A) = __rustylr_args.pop().unwrap() {
            A
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant27({ Some(A) }))
    }
    fn reduce__ParList_Question53_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        Ok(ChunkNodeEnum::Variant27({ None }))
    }
    fn reduce__Group54_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        __rustylr_args.pop();
        let mut __rustylr_group_elem1 = if let ChunkNodeEnum::Terminals(__rustylr_group_elem1) =
            __rustylr_args.pop().unwrap()
        {
            __rustylr_group_elem1
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Terminals(__rustylr_group_elem1))
    }
    fn reduce___Group54_Question55_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        let mut A = if let ChunkNodeEnum::Terminals(A) = __rustylr_args.pop().unwrap() {
            A
        } else {
            unreachable!()
        };
        Ok(ChunkNodeEnum::Variant26({ Some(A) }))
    }
    fn reduce___Group54_Question55_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        Ok(ChunkNodeEnum::Variant26({ None }))
    }
    fn reduce_Augmented_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkNodeEnum, ParseError> {
        __rustylr_args.clear();
        Ok(ChunkNodeEnum::NonTerminals)
    }
}
#[allow(
    unused_braces,
    unused_parens,
    non_snake_case,
    non_camel_case_types,
    unused_variables
)]
impl ::rusty_lr::glr::NodeData for ChunkNodeEnum {
    type Term = Token;
    type NonTerm = ChunkNonTerminals;
    type ReduceActionError = ParseError;
    type UserData = ();
    type StartType = statement::Block;
    fn new_term(term: Token) -> Self {
        ChunkNodeEnum::Terminals(term)
    }
    fn new_nonterm(
        rule_index: usize,
        reduce_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Self::Term,
        user_data: &mut Self::UserData,
    ) -> Result<Self, Self::ReduceActionError> {
        match rule_index {
            0usize => Self::reduce_Chunk_0(reduce_args, shift, lookahead, user_data),
            1usize => Self::reduce_Block_0(reduce_args, shift, lookahead, user_data),
            2usize => Self::reduce_Statement_0(reduce_args, shift, lookahead, user_data),
            3usize => Self::reduce_Statement_1(reduce_args, shift, lookahead, user_data),
            4usize => Self::reduce_Statement_2(reduce_args, shift, lookahead, user_data),
            5usize => Self::reduce_Statement_3(reduce_args, shift, lookahead, user_data),
            6usize => Self::reduce_Statement_4(reduce_args, shift, lookahead, user_data),
            7usize => Self::reduce_Statement_5(reduce_args, shift, lookahead, user_data),
            8usize => Self::reduce_Statement_6(reduce_args, shift, lookahead, user_data),
            9usize => Self::reduce_Statement_7(reduce_args, shift, lookahead, user_data),
            10usize => Self::reduce_Statement_8(reduce_args, shift, lookahead, user_data),
            11usize => Self::reduce_Statement_9(reduce_args, shift, lookahead, user_data),
            12usize => Self::reduce_Statement_10(reduce_args, shift, lookahead, user_data),
            13usize => Self::reduce_Statement_11(reduce_args, shift, lookahead, user_data),
            14usize => Self::reduce_Statement_12(reduce_args, shift, lookahead, user_data),
            15usize => Self::reduce_Statement_13(reduce_args, shift, lookahead, user_data),
            16usize => Self::reduce_Statement_14(reduce_args, shift, lookahead, user_data),
            17usize => Self::reduce_ElseIf_0(reduce_args, shift, lookahead, user_data),
            18usize => Self::reduce_ReturnStatement_0(reduce_args, shift, lookahead, user_data),
            19usize => Self::reduce_Var_0(reduce_args, shift, lookahead, user_data),
            20usize => Self::reduce_Var_1(reduce_args, shift, lookahead, user_data),
            21usize => Self::reduce_Var_2(reduce_args, shift, lookahead, user_data),
            22usize => Self::reduce_PrefixExp_0(reduce_args, shift, lookahead, user_data),
            23usize => Self::reduce_PrefixExp_1(reduce_args, shift, lookahead, user_data),
            24usize => Self::reduce_PrefixExp_2(reduce_args, shift, lookahead, user_data),
            25usize => Self::reduce_FunctionCall_0(reduce_args, shift, lookahead, user_data),
            26usize => Self::reduce_FunctionCall_1(reduce_args, shift, lookahead, user_data),
            27usize => Self::reduce_Args_0(reduce_args, shift, lookahead, user_data),
            28usize => Self::reduce_Args_1(reduce_args, shift, lookahead, user_data),
            29usize => Self::reduce_Args_2(reduce_args, shift, lookahead, user_data),
            30usize => Self::reduce_VarList_0(reduce_args, shift, lookahead, user_data),
            31usize => Self::reduce_VarList_1(reduce_args, shift, lookahead, user_data),
            32usize => Self::reduce_ExpList1_0(reduce_args, shift, lookahead, user_data),
            33usize => Self::reduce_ExpList1_1(reduce_args, shift, lookahead, user_data),
            34usize => Self::reduce_ExpList0_0(reduce_args, shift, lookahead, user_data),
            35usize => Self::reduce_ExpList0_1(reduce_args, shift, lookahead, user_data),
            36usize => Self::reduce_NameList_0(reduce_args, shift, lookahead, user_data),
            37usize => Self::reduce_NameList_1(reduce_args, shift, lookahead, user_data),
            38usize => Self::reduce_AttName_0(reduce_args, shift, lookahead, user_data),
            39usize => Self::reduce_AttNameList_0(reduce_args, shift, lookahead, user_data),
            40usize => Self::reduce_AttNameList_1(reduce_args, shift, lookahead, user_data),
            41usize => Self::reduce_Attrib_0(reduce_args, shift, lookahead, user_data),
            42usize => Self::reduce_Attrib_1(reduce_args, shift, lookahead, user_data),
            43usize => Self::reduce_Exp_0(reduce_args, shift, lookahead, user_data),
            44usize => Self::reduce_Exp0_0(reduce_args, shift, lookahead, user_data),
            45usize => Self::reduce_Exp0_1(reduce_args, shift, lookahead, user_data),
            46usize => Self::reduce_Exp0_2(reduce_args, shift, lookahead, user_data),
            47usize => Self::reduce_Exp0_3(reduce_args, shift, lookahead, user_data),
            48usize => Self::reduce_Exp0_4(reduce_args, shift, lookahead, user_data),
            49usize => Self::reduce_Exp0_5(reduce_args, shift, lookahead, user_data),
            50usize => Self::reduce_Exp0_6(reduce_args, shift, lookahead, user_data),
            51usize => Self::reduce_Exp0_7(reduce_args, shift, lookahead, user_data),
            52usize => Self::reduce_Exp1_0(reduce_args, shift, lookahead, user_data),
            53usize => Self::reduce_Exp1_1(reduce_args, shift, lookahead, user_data),
            54usize => Self::reduce_Exp2_0(reduce_args, shift, lookahead, user_data),
            55usize => Self::reduce_Exp2_1(reduce_args, shift, lookahead, user_data),
            56usize => Self::reduce_Exp2_2(reduce_args, shift, lookahead, user_data),
            57usize => Self::reduce_Exp2_3(reduce_args, shift, lookahead, user_data),
            58usize => Self::reduce_Exp2_4(reduce_args, shift, lookahead, user_data),
            59usize => Self::reduce_Exp2_5(reduce_args, shift, lookahead, user_data),
            60usize => Self::reduce_Exp3_0(reduce_args, shift, lookahead, user_data),
            61usize => Self::reduce_Exp3_1(reduce_args, shift, lookahead, user_data),
            62usize => Self::reduce_Exp3_2(reduce_args, shift, lookahead, user_data),
            63usize => Self::reduce_Exp3_3(reduce_args, shift, lookahead, user_data),
            64usize => Self::reduce_Exp3_4(reduce_args, shift, lookahead, user_data),
            65usize => Self::reduce_Exp4_0(reduce_args, shift, lookahead, user_data),
            66usize => Self::reduce_Exp4_1(reduce_args, shift, lookahead, user_data),
            67usize => Self::reduce_Exp4_2(reduce_args, shift, lookahead, user_data),
            68usize => Self::reduce_Exp5_0(reduce_args, shift, lookahead, user_data),
            69usize => Self::reduce_Exp5_1(reduce_args, shift, lookahead, user_data),
            70usize => Self::reduce_Exp6_0(reduce_args, shift, lookahead, user_data),
            71usize => Self::reduce_Exp6_1(reduce_args, shift, lookahead, user_data),
            72usize => Self::reduce_Exp6_2(reduce_args, shift, lookahead, user_data),
            73usize => Self::reduce_Exp7_0(reduce_args, shift, lookahead, user_data),
            74usize => Self::reduce_Exp7_1(reduce_args, shift, lookahead, user_data),
            75usize => Self::reduce_Exp8_0(reduce_args, shift, lookahead, user_data),
            76usize => Self::reduce_Exp8_1(reduce_args, shift, lookahead, user_data),
            77usize => Self::reduce_Exp9_0(reduce_args, shift, lookahead, user_data),
            78usize => Self::reduce_Exp9_1(reduce_args, shift, lookahead, user_data),
            79usize => Self::reduce_Exp10_0(reduce_args, shift, lookahead, user_data),
            80usize => Self::reduce_Exp10_1(reduce_args, shift, lookahead, user_data),
            81usize => Self::reduce_Exp10_2(reduce_args, shift, lookahead, user_data),
            82usize => Self::reduce_Exp10_3(reduce_args, shift, lookahead, user_data),
            83usize => Self::reduce_Exp10_4(reduce_args, shift, lookahead, user_data),
            84usize => Self::reduce_Exp10_5(reduce_args, shift, lookahead, user_data),
            85usize => Self::reduce_Exp10_6(reduce_args, shift, lookahead, user_data),
            86usize => Self::reduce_Exp11_0(reduce_args, shift, lookahead, user_data),
            87usize => Self::reduce_Exp11_1(reduce_args, shift, lookahead, user_data),
            88usize => Self::reduce_Exp12_0(reduce_args, shift, lookahead, user_data),
            89usize => Self::reduce_Exp12_1(reduce_args, shift, lookahead, user_data),
            90usize => Self::reduce_TableConstructor_0(reduce_args, shift, lookahead, user_data),
            91usize => Self::reduce_FieldList1_0(reduce_args, shift, lookahead, user_data),
            92usize => Self::reduce_FieldList1_1(reduce_args, shift, lookahead, user_data),
            93usize => Self::reduce_FieldList_0(reduce_args, shift, lookahead, user_data),
            94usize => Self::reduce_FieldList_1(reduce_args, shift, lookahead, user_data),
            95usize => Self::reduce_Field_0(reduce_args, shift, lookahead, user_data),
            96usize => Self::reduce_Field_1(reduce_args, shift, lookahead, user_data),
            97usize => Self::reduce_Field_2(reduce_args, shift, lookahead, user_data),
            98usize => Self::reduce_FieldSep_0(reduce_args, shift, lookahead, user_data),
            99usize => Self::reduce_FieldSep_1(reduce_args, shift, lookahead, user_data),
            100usize => Self::reduce_FunctionDef_0(reduce_args, shift, lookahead, user_data),
            101usize => Self::reduce_FuncBody_0(reduce_args, shift, lookahead, user_data),
            102usize => Self::reduce_FuncName1_0(reduce_args, shift, lookahead, user_data),
            103usize => Self::reduce_FuncName1_1(reduce_args, shift, lookahead, user_data),
            104usize => Self::reduce_FuncName_0(reduce_args, shift, lookahead, user_data),
            105usize => Self::reduce_FuncName_1(reduce_args, shift, lookahead, user_data),
            106usize => Self::reduce_ParList_0(reduce_args, shift, lookahead, user_data),
            107usize => Self::reduce_ParList_1(reduce_args, shift, lookahead, user_data),
            108usize => Self::reduce__Statement_Plus40_0(reduce_args, shift, lookahead, user_data),
            109usize => Self::reduce__Statement_Plus40_1(reduce_args, shift, lookahead, user_data),
            110usize => Self::reduce__Statement_Star41_0(reduce_args, shift, lookahead, user_data),
            111usize => Self::reduce__Statement_Star41_1(reduce_args, shift, lookahead, user_data),
            112usize => {
                Self::reduce__ReturnStatement_Question42_0(reduce_args, shift, lookahead, user_data)
            }
            113usize => {
                Self::reduce__ReturnStatement_Question42_1(reduce_args, shift, lookahead, user_data)
            }
            114usize => Self::reduce__ElseIf_Plus43_0(reduce_args, shift, lookahead, user_data),
            115usize => Self::reduce__ElseIf_Plus43_1(reduce_args, shift, lookahead, user_data),
            116usize => Self::reduce__ElseIf_Star44_0(reduce_args, shift, lookahead, user_data),
            117usize => Self::reduce__ElseIf_Star44_1(reduce_args, shift, lookahead, user_data),
            118usize => Self::reduce__Group45_0(reduce_args, shift, lookahead, user_data),
            119usize => {
                Self::reduce___Group45_Question46_0(reduce_args, shift, lookahead, user_data)
            }
            120usize => {
                Self::reduce___Group45_Question46_1(reduce_args, shift, lookahead, user_data)
            }
            121usize => Self::reduce__Group47_0(reduce_args, shift, lookahead, user_data),
            122usize => {
                Self::reduce___Group47_Question48_0(reduce_args, shift, lookahead, user_data)
            }
            123usize => {
                Self::reduce___Group47_Question48_1(reduce_args, shift, lookahead, user_data)
            }
            124usize => Self::reduce__Group49_0(reduce_args, shift, lookahead, user_data),
            125usize => {
                Self::reduce___Group49_Question50_0(reduce_args, shift, lookahead, user_data)
            }
            126usize => {
                Self::reduce___Group49_Question50_1(reduce_args, shift, lookahead, user_data)
            }
            127usize => {
                Self::reduce__semicolon_Question51_0(reduce_args, shift, lookahead, user_data)
            }
            128usize => {
                Self::reduce__semicolon_Question51_1(reduce_args, shift, lookahead, user_data)
            }
            129usize => {
                Self::reduce__FieldSep_Question52_0(reduce_args, shift, lookahead, user_data)
            }
            130usize => {
                Self::reduce__FieldSep_Question52_1(reduce_args, shift, lookahead, user_data)
            }
            131usize => {
                Self::reduce__ParList_Question53_0(reduce_args, shift, lookahead, user_data)
            }
            132usize => {
                Self::reduce__ParList_Question53_1(reduce_args, shift, lookahead, user_data)
            }
            133usize => Self::reduce__Group54_0(reduce_args, shift, lookahead, user_data),
            134usize => {
                Self::reduce___Group54_Question55_0(reduce_args, shift, lookahead, user_data)
            }
            135usize => {
                Self::reduce___Group54_Question55_1(reduce_args, shift, lookahead, user_data)
            }
            136usize => Self::reduce_Augmented_0(reduce_args, shift, lookahead, user_data),
            _ => {
                unreachable!("Invalid Rule: {}", rule_index);
            }
        }
    }
    fn into_start(self) -> Self::StartType {
        match self {
            ChunkNodeEnum::Variant2(start) => start,
            _ => unreachable!(),
        }
    }
}
#[doc = r" struct that holds parser data, DFA tables"]
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut
)]
pub struct ChunkParser {
    #[doc = r" production rules"]
    pub rules: Vec<ChunkRule>,
    #[doc = r" states"]
    pub states: Vec<ChunkState>,
}
impl ::rusty_lr::glr::Parser for ChunkParser {
    type Term = Token;
    type NonTerm = ChunkNonTerminals;
    fn get_rules(&self) -> &[ChunkRule] {
        &self.rules
    }
    fn get_states(&self) -> &[ChunkState] {
        &self.states
    }
}
#[doc = r" Parser is holding DFA state tables and production rules"]
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut
)]
impl ChunkParser {
    #[doc = r" Create new parser instance."]
    #[doc = r" Parser can be reused with different context, for multiple parsing."]
    pub fn new() -> Self {
        let __rustylr_terminals: Vec<Token> = vec![
            Token::new_type(TokenType::Ident("".to_string())),
            Token::new_type(TokenType::String("".to_string())),
            Token::new_type(TokenType::Numeric(IntOrFloat::Int(0))),
            Token::new_type(TokenType::Nil),
            Token::new_type(TokenType::Bool(false)),
            Token::new_type(TokenType::Plus),
            Token::new_type(TokenType::Minus),
            Token::new_type(TokenType::Asterisk),
            Token::new_type(TokenType::Slash),
            Token::new_type(TokenType::Percent),
            Token::new_type(TokenType::Caret),
            Token::new_type(TokenType::Hash),
            Token::new_type(TokenType::Ampersand),
            Token::new_type(TokenType::Tilde),
            Token::new_type(TokenType::Pipe),
            Token::new_type(TokenType::LessLess),
            Token::new_type(TokenType::GreaterGreater),
            Token::new_type(TokenType::SlashSlash),
            Token::new_type(TokenType::EqualEqual),
            Token::new_type(TokenType::TildeEqual),
            Token::new_type(TokenType::LessEqual),
            Token::new_type(TokenType::GreaterEqual),
            Token::new_type(TokenType::Less),
            Token::new_type(TokenType::Greater),
            Token::new_type(TokenType::Equal),
            Token::new_type(TokenType::LParen),
            Token::new_type(TokenType::RParen),
            Token::new_type(TokenType::LBrace),
            Token::new_type(TokenType::RBrace),
            Token::new_type(TokenType::LBracket),
            Token::new_type(TokenType::RBracket),
            Token::new_type(TokenType::ColonColon),
            Token::new_type(TokenType::Semicolon),
            Token::new_type(TokenType::Colon),
            Token::new_type(TokenType::Comma),
            Token::new_type(TokenType::Dot),
            Token::new_type(TokenType::DotDot),
            Token::new_type(TokenType::DotDotDot),
            Token::new_type(TokenType::And),
            Token::new_type(TokenType::Break),
            Token::new_type(TokenType::Do),
            Token::new_type(TokenType::Else),
            Token::new_type(TokenType::Elseif),
            Token::new_type(TokenType::End),
            Token::new_type(TokenType::For),
            Token::new_type(TokenType::Function),
            Token::new_type(TokenType::Goto),
            Token::new_type(TokenType::If),
            Token::new_type(TokenType::In),
            Token::new_type(TokenType::Local),
            Token::new_type(TokenType::Not),
            Token::new_type(TokenType::Or),
            Token::new_type(TokenType::Repeat),
            Token::new_type(TokenType::Return),
            Token::new_type(TokenType::Then),
            Token::new_type(TokenType::Until),
            Token::new_type(TokenType::While),
            Token::new_type(TokenType::Eof),
        ];
        const RUSTYLR_RULES_TOKENS: &[&[::rusty_lr::Token<u8, ChunkNonTerminals>]] = &[
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::Block)],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::_Statement_Star41),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::_ReturnStatement_Question42),
            ],
            &[::rusty_lr::Token::Term(32)],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::VarList),
                ::rusty_lr::Token::Term(24),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::ExpList1),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::FunctionCall)],
            &[
                ::rusty_lr::Token::Term(31),
                ::rusty_lr::Token::Term(0),
                ::rusty_lr::Token::Term(31),
            ],
            &[::rusty_lr::Token::Term(39)],
            &[::rusty_lr::Token::Term(46), ::rusty_lr::Token::Term(0)],
            &[
                ::rusty_lr::Token::Term(40),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Block),
                ::rusty_lr::Token::Term(43),
            ],
            &[
                ::rusty_lr::Token::Term(56),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp),
                ::rusty_lr::Token::Term(40),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Block),
                ::rusty_lr::Token::Term(43),
            ],
            &[
                ::rusty_lr::Token::Term(52),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Block),
                ::rusty_lr::Token::Term(55),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp),
            ],
            &[
                ::rusty_lr::Token::Term(47),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp),
                ::rusty_lr::Token::Term(54),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Block),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::_ElseIf_Star44),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::__Group45_Question46),
                ::rusty_lr::Token::Term(43),
            ],
            &[
                ::rusty_lr::Token::Term(44),
                ::rusty_lr::Token::Term(0),
                ::rusty_lr::Token::Term(24),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp),
                ::rusty_lr::Token::Term(34),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::__Group47_Question48),
                ::rusty_lr::Token::Term(40),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Block),
                ::rusty_lr::Token::Term(43),
            ],
            &[
                ::rusty_lr::Token::Term(44),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::NameList),
                ::rusty_lr::Token::Term(48),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::ExpList1),
                ::rusty_lr::Token::Term(40),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Block),
                ::rusty_lr::Token::Term(43),
            ],
            &[
                ::rusty_lr::Token::Term(45),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::FuncName),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::FuncBody),
            ],
            &[
                ::rusty_lr::Token::Term(49),
                ::rusty_lr::Token::Term(45),
                ::rusty_lr::Token::Term(0),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::FuncBody),
            ],
            &[
                ::rusty_lr::Token::Term(49),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::AttNameList),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::__Group49_Question50),
            ],
            &[
                ::rusty_lr::Token::Term(42),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp),
                ::rusty_lr::Token::Term(54),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Block),
            ],
            &[
                ::rusty_lr::Token::Term(53),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::ExpList0),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::_semicolon_Question51),
            ],
            &[::rusty_lr::Token::Term(0)],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::PrefixExp),
                ::rusty_lr::Token::Term(29),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp),
                ::rusty_lr::Token::Term(30),
            ],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::PrefixExp),
                ::rusty_lr::Token::Term(35),
                ::rusty_lr::Token::Term(0),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::Var)],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::FunctionCall)],
            &[
                ::rusty_lr::Token::Term(25),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp),
                ::rusty_lr::Token::Term(26),
            ],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::PrefixExp),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Args),
            ],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::PrefixExp),
                ::rusty_lr::Token::Term(33),
                ::rusty_lr::Token::Term(0),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Args),
            ],
            &[
                ::rusty_lr::Token::Term(25),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::ExpList0),
                ::rusty_lr::Token::Term(26),
            ],
            &[::rusty_lr::Token::NonTerm(
                ChunkNonTerminals::TableConstructor,
            )],
            &[::rusty_lr::Token::Term(1)],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::VarList),
                ::rusty_lr::Token::Term(34),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Var),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::Var)],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::ExpList1),
                ::rusty_lr::Token::Term(34),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp)],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::ExpList1)],
            &[],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::NameList),
                ::rusty_lr::Token::Term(34),
                ::rusty_lr::Token::Term(0),
            ],
            &[::rusty_lr::Token::Term(0)],
            &[
                ::rusty_lr::Token::Term(0),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Attrib),
            ],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::AttNameList),
                ::rusty_lr::Token::Term(34),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::AttName),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::AttName)],
            &[
                ::rusty_lr::Token::Term(22),
                ::rusty_lr::Token::Term(0),
                ::rusty_lr::Token::Term(23),
            ],
            &[],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp12)],
            &[::rusty_lr::Token::Term(2)],
            &[::rusty_lr::Token::Term(3)],
            &[::rusty_lr::Token::Term(1)],
            &[::rusty_lr::Token::Term(4)],
            &[::rusty_lr::Token::Term(37)],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::FunctionDef)],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::PrefixExp)],
            &[::rusty_lr::Token::NonTerm(
                ChunkNonTerminals::TableConstructor,
            )],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp0),
                ::rusty_lr::Token::Term(10),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp1),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp0)],
            &[
                ::rusty_lr::Token::Term(50),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp2),
            ],
            &[
                ::rusty_lr::Token::Term(11),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp2),
            ],
            &[
                ::rusty_lr::Token::Term(6),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp2),
            ],
            &[
                ::rusty_lr::Token::Term(5),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp2),
            ],
            &[
                ::rusty_lr::Token::Term(13),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp2),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp1)],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp3),
                ::rusty_lr::Token::Term(7),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp2),
            ],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp3),
                ::rusty_lr::Token::Term(8),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp2),
            ],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp3),
                ::rusty_lr::Token::Term(17),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp2),
            ],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp3),
                ::rusty_lr::Token::Term(9),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp2),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp2)],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp4),
                ::rusty_lr::Token::Term(5),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp3),
            ],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp4),
                ::rusty_lr::Token::Term(6),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp3),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp3)],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp4),
                ::rusty_lr::Token::Term(36),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp5),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp4)],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp6),
                ::rusty_lr::Token::Term(15),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp5),
            ],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp6),
                ::rusty_lr::Token::Term(16),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp5),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp5)],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp7),
                ::rusty_lr::Token::Term(12),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp6),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp6)],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp8),
                ::rusty_lr::Token::Term(13),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp7),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp7)],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp9),
                ::rusty_lr::Token::Term(14),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp8),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp8)],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp10),
                ::rusty_lr::Token::Term(22),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp9),
            ],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp10),
                ::rusty_lr::Token::Term(20),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp9),
            ],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp10),
                ::rusty_lr::Token::Term(23),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp9),
            ],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp10),
                ::rusty_lr::Token::Term(21),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp9),
            ],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp10),
                ::rusty_lr::Token::Term(19),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp9),
            ],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp10),
                ::rusty_lr::Token::Term(18),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp9),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp9)],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp11),
                ::rusty_lr::Token::Term(38),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp10),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp10)],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp12),
                ::rusty_lr::Token::Term(51),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp11),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp11)],
            &[
                ::rusty_lr::Token::Term(27),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::FieldList),
                ::rusty_lr::Token::Term(28),
            ],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::FieldList1),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::FieldSep),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Field),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::Field)],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::FieldList1),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::_FieldSep_Question52),
            ],
            &[],
            &[
                ::rusty_lr::Token::Term(29),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp),
                ::rusty_lr::Token::Term(30),
                ::rusty_lr::Token::Term(24),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp),
            ],
            &[
                ::rusty_lr::Token::Term(0),
                ::rusty_lr::Token::Term(24),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp)],
            &[::rusty_lr::Token::Term(34)],
            &[::rusty_lr::Token::Term(32)],
            &[
                ::rusty_lr::Token::Term(45),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::FuncBody),
            ],
            &[
                ::rusty_lr::Token::Term(25),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::_ParList_Question53),
                ::rusty_lr::Token::Term(26),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Block),
                ::rusty_lr::Token::Term(43),
            ],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::FuncName1),
                ::rusty_lr::Token::Term(35),
                ::rusty_lr::Token::Term(0),
            ],
            &[::rusty_lr::Token::Term(0)],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::FuncName1),
                ::rusty_lr::Token::Term(33),
                ::rusty_lr::Token::Term(0),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::FuncName1)],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::NameList),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::__Group54_Question55),
            ],
            &[::rusty_lr::Token::Term(37)],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::Statement)],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::_Statement_Plus40),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Statement),
            ],
            &[::rusty_lr::Token::NonTerm(
                ChunkNonTerminals::_Statement_Plus40,
            )],
            &[],
            &[::rusty_lr::Token::NonTerm(
                ChunkNonTerminals::ReturnStatement,
            )],
            &[],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::ElseIf)],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::_ElseIf_Plus43),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::ElseIf),
            ],
            &[::rusty_lr::Token::NonTerm(
                ChunkNonTerminals::_ElseIf_Plus43,
            )],
            &[],
            &[
                ::rusty_lr::Token::Term(41),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Block),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::_Group45)],
            &[],
            &[
                ::rusty_lr::Token::Term(34),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Exp),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::_Group47)],
            &[],
            &[
                ::rusty_lr::Token::Term(24),
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::ExpList1),
            ],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::_Group49)],
            &[],
            &[::rusty_lr::Token::Term(32)],
            &[],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::FieldSep)],
            &[],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::ParList)],
            &[],
            &[::rusty_lr::Token::Term(34), ::rusty_lr::Token::Term(37)],
            &[::rusty_lr::Token::NonTerm(ChunkNonTerminals::_Group54)],
            &[],
            &[
                ::rusty_lr::Token::NonTerm(ChunkNonTerminals::Chunk),
                ::rusty_lr::Token::Term(57),
            ],
        ];
        const RUSTYLR_RULES_NAME: &[ChunkNonTerminals] = &[
            ChunkNonTerminals::Chunk,
            ChunkNonTerminals::Block,
            ChunkNonTerminals::Statement,
            ChunkNonTerminals::Statement,
            ChunkNonTerminals::Statement,
            ChunkNonTerminals::Statement,
            ChunkNonTerminals::Statement,
            ChunkNonTerminals::Statement,
            ChunkNonTerminals::Statement,
            ChunkNonTerminals::Statement,
            ChunkNonTerminals::Statement,
            ChunkNonTerminals::Statement,
            ChunkNonTerminals::Statement,
            ChunkNonTerminals::Statement,
            ChunkNonTerminals::Statement,
            ChunkNonTerminals::Statement,
            ChunkNonTerminals::Statement,
            ChunkNonTerminals::ElseIf,
            ChunkNonTerminals::ReturnStatement,
            ChunkNonTerminals::Var,
            ChunkNonTerminals::Var,
            ChunkNonTerminals::Var,
            ChunkNonTerminals::PrefixExp,
            ChunkNonTerminals::PrefixExp,
            ChunkNonTerminals::PrefixExp,
            ChunkNonTerminals::FunctionCall,
            ChunkNonTerminals::FunctionCall,
            ChunkNonTerminals::Args,
            ChunkNonTerminals::Args,
            ChunkNonTerminals::Args,
            ChunkNonTerminals::VarList,
            ChunkNonTerminals::VarList,
            ChunkNonTerminals::ExpList1,
            ChunkNonTerminals::ExpList1,
            ChunkNonTerminals::ExpList0,
            ChunkNonTerminals::ExpList0,
            ChunkNonTerminals::NameList,
            ChunkNonTerminals::NameList,
            ChunkNonTerminals::AttName,
            ChunkNonTerminals::AttNameList,
            ChunkNonTerminals::AttNameList,
            ChunkNonTerminals::Attrib,
            ChunkNonTerminals::Attrib,
            ChunkNonTerminals::Exp,
            ChunkNonTerminals::Exp0,
            ChunkNonTerminals::Exp0,
            ChunkNonTerminals::Exp0,
            ChunkNonTerminals::Exp0,
            ChunkNonTerminals::Exp0,
            ChunkNonTerminals::Exp0,
            ChunkNonTerminals::Exp0,
            ChunkNonTerminals::Exp0,
            ChunkNonTerminals::Exp1,
            ChunkNonTerminals::Exp1,
            ChunkNonTerminals::Exp2,
            ChunkNonTerminals::Exp2,
            ChunkNonTerminals::Exp2,
            ChunkNonTerminals::Exp2,
            ChunkNonTerminals::Exp2,
            ChunkNonTerminals::Exp2,
            ChunkNonTerminals::Exp3,
            ChunkNonTerminals::Exp3,
            ChunkNonTerminals::Exp3,
            ChunkNonTerminals::Exp3,
            ChunkNonTerminals::Exp3,
            ChunkNonTerminals::Exp4,
            ChunkNonTerminals::Exp4,
            ChunkNonTerminals::Exp4,
            ChunkNonTerminals::Exp5,
            ChunkNonTerminals::Exp5,
            ChunkNonTerminals::Exp6,
            ChunkNonTerminals::Exp6,
            ChunkNonTerminals::Exp6,
            ChunkNonTerminals::Exp7,
            ChunkNonTerminals::Exp7,
            ChunkNonTerminals::Exp8,
            ChunkNonTerminals::Exp8,
            ChunkNonTerminals::Exp9,
            ChunkNonTerminals::Exp9,
            ChunkNonTerminals::Exp10,
            ChunkNonTerminals::Exp10,
            ChunkNonTerminals::Exp10,
            ChunkNonTerminals::Exp10,
            ChunkNonTerminals::Exp10,
            ChunkNonTerminals::Exp10,
            ChunkNonTerminals::Exp10,
            ChunkNonTerminals::Exp11,
            ChunkNonTerminals::Exp11,
            ChunkNonTerminals::Exp12,
            ChunkNonTerminals::Exp12,
            ChunkNonTerminals::TableConstructor,
            ChunkNonTerminals::FieldList1,
            ChunkNonTerminals::FieldList1,
            ChunkNonTerminals::FieldList,
            ChunkNonTerminals::FieldList,
            ChunkNonTerminals::Field,
            ChunkNonTerminals::Field,
            ChunkNonTerminals::Field,
            ChunkNonTerminals::FieldSep,
            ChunkNonTerminals::FieldSep,
            ChunkNonTerminals::FunctionDef,
            ChunkNonTerminals::FuncBody,
            ChunkNonTerminals::FuncName1,
            ChunkNonTerminals::FuncName1,
            ChunkNonTerminals::FuncName,
            ChunkNonTerminals::FuncName,
            ChunkNonTerminals::ParList,
            ChunkNonTerminals::ParList,
            ChunkNonTerminals::_Statement_Plus40,
            ChunkNonTerminals::_Statement_Plus40,
            ChunkNonTerminals::_Statement_Star41,
            ChunkNonTerminals::_Statement_Star41,
            ChunkNonTerminals::_ReturnStatement_Question42,
            ChunkNonTerminals::_ReturnStatement_Question42,
            ChunkNonTerminals::_ElseIf_Plus43,
            ChunkNonTerminals::_ElseIf_Plus43,
            ChunkNonTerminals::_ElseIf_Star44,
            ChunkNonTerminals::_ElseIf_Star44,
            ChunkNonTerminals::_Group45,
            ChunkNonTerminals::__Group45_Question46,
            ChunkNonTerminals::__Group45_Question46,
            ChunkNonTerminals::_Group47,
            ChunkNonTerminals::__Group47_Question48,
            ChunkNonTerminals::__Group47_Question48,
            ChunkNonTerminals::_Group49,
            ChunkNonTerminals::__Group49_Question50,
            ChunkNonTerminals::__Group49_Question50,
            ChunkNonTerminals::_semicolon_Question51,
            ChunkNonTerminals::_semicolon_Question51,
            ChunkNonTerminals::_FieldSep_Question52,
            ChunkNonTerminals::_FieldSep_Question52,
            ChunkNonTerminals::_ParList_Question53,
            ChunkNonTerminals::_ParList_Question53,
            ChunkNonTerminals::_Group54,
            ChunkNonTerminals::__Group54_Question55,
            ChunkNonTerminals::__Group54_Question55,
            ChunkNonTerminals::Augmented,
        ];
        let rules: Vec<ChunkRule> = RUSTYLR_RULES_NAME
            .iter()
            .zip(RUSTYLR_RULES_TOKENS.iter())
            .map(|(name, tokens)| ChunkRule {
                name: *name,
                rule: tokens
                    .iter()
                    .map(|token| match token {
                        ::rusty_lr::Token::Term(term) => {
                            ::rusty_lr::Token::Term(__rustylr_terminals[*term as usize].clone())
                        }
                        ::rusty_lr::Token::NonTerm(nonterm) => ::rusty_lr::Token::NonTerm(*nonterm),
                    })
                    .collect(),
            })
            .collect();
        const RUSTYLR_REDUCE_TERMINALS_CACHE: &[&[u8]] = &[
            &[53, 57],
            &[
                0, 1, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
                26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
                49, 51, 52, 53, 54, 55, 56, 57,
            ],
            &[
                0, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 26, 28,
                30, 31, 32, 34, 36, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55,
                56, 57,
            ],
            &[28],
            &[
                1, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 27, 28,
                29, 32, 33, 34, 35, 36, 38, 51,
            ],
            &[26],
            &[26, 34],
            &[26, 34, 48],
            &[43, 53],
            &[
                0, 25, 31, 32, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 52, 53, 55, 56, 57,
            ],
            &[34, 48],
            &[25, 33, 35],
            &[25],
            &[
                0, 1, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 26,
                27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49,
                51, 52, 53, 54, 55, 56, 57,
            ],
            &[
                0, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 26, 28, 30,
                31, 32, 34, 36, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56,
                57,
            ],
            &[28, 32, 34],
            &[
                0, 5, 6, 7, 8, 9, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 26, 28, 30,
                31, 32, 34, 36, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56,
                57,
            ],
            &[26, 32, 41, 42, 43, 55, 57],
            &[
                0, 24, 25, 31, 32, 34, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 52, 53, 55, 56, 57,
            ],
            &[53, 55],
            &[
                0, 5, 6, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 25, 26, 28, 30, 31, 32, 34,
                36, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56, 57,
            ],
            &[
                0, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 25, 26, 28, 30, 31, 32, 34, 38, 39,
                40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56, 57,
            ],
            &[
                0, 25, 26, 31, 32, 34, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 52, 53, 55, 56, 57,
            ],
            &[
                0, 12, 13, 14, 18, 19, 20, 21, 22, 23, 25, 26, 28, 30, 31, 32, 34, 38, 39, 40, 41,
                42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56, 57,
            ],
            &[
                0, 13, 14, 18, 19, 20, 21, 22, 23, 25, 26, 28, 30, 31, 32, 34, 38, 39, 40, 41, 42,
                43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56, 57,
            ],
            &[
                0, 14, 18, 19, 20, 21, 22, 23, 25, 26, 28, 30, 31, 32, 34, 38, 39, 40, 41, 42, 43,
                44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56, 57,
            ],
            &[
                0, 18, 19, 20, 21, 22, 23, 25, 26, 28, 30, 31, 32, 34, 38, 39, 40, 41, 42, 43, 44,
                45, 46, 47, 49, 51, 52, 53, 54, 55, 56, 57,
            ],
            &[
                0, 25, 26, 28, 30, 31, 32, 34, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52,
                53, 54, 55, 56, 57,
            ],
            &[
                0, 25, 26, 28, 30, 31, 32, 34, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53,
                54, 55, 56, 57,
            ],
            &[
                0, 25, 26, 28, 30, 31, 32, 34, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 52, 53, 54,
                55, 56, 57,
            ],
            &[0, 1, 2, 3, 4, 5, 6, 11, 13, 25, 27, 28, 29, 37, 45, 50],
            &[1, 25, 27, 29, 33, 35],
            &[24, 34],
            &[41, 42, 43, 53, 55, 57],
            &[41, 42, 43, 55, 57],
            &[32, 41, 42, 43, 55, 57],
            &[41, 42, 43, 53],
            &[40],
            &[41, 43],
            &[41, 42, 43],
            &[43],
            &[57],
        ];
        const RUSTYLR_RULESET_SHIFTED0_CACHE: &[&[u8]] = &[
            &[
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 19, 20, 21, 22, 23, 24,
                25, 26, 30, 31, 108, 109, 110, 111, 136,
            ],
            &[],
            &[
                19, 20, 21, 22, 23, 24, 25, 26, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,
                56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
                77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 100,
            ],
            &[
                19, 20, 21, 22, 23, 24, 25, 26, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
                57, 58, 59, 90, 100,
            ],
            &[
                19, 20, 21, 22, 23, 24, 25, 26, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,
                56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
                77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97,
                100,
            ],
            &[101],
            &[36, 37, 106, 107, 131, 132],
            &[133, 134, 135],
            &[
                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 19, 20, 21, 22, 23, 24, 25,
                26, 30, 31, 108, 109, 110, 111,
            ],
            &[36, 37],
            &[102, 103, 104, 105],
            &[27, 28, 29, 90],
            &[
                19, 20, 21, 22, 23, 24, 25, 26, 32, 33, 34, 35, 43, 44, 45, 46, 47, 48, 49, 50, 51,
                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72,
                73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 100,
            ],
            &[
                19, 20, 21, 22, 23, 24, 25, 26, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 90, 100,
            ],
            &[38, 39, 40],
            &[41, 42],
            &[124, 125, 126],
            &[
                19, 20, 21, 22, 23, 24, 25, 26, 32, 33, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
                54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
                75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 100,
            ],
            &[
                19, 20, 21, 22, 23, 24, 25, 26, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
                57, 58, 59, 60, 61, 62, 63, 64, 90, 100,
            ],
            &[
                19, 20, 21, 22, 23, 24, 25, 26, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
                57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 90, 100,
            ],
            &[
                19, 20, 21, 22, 23, 24, 25, 26, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
                57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 90, 100,
            ],
            &[
                19, 20, 21, 22, 23, 24, 25, 26, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
                57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 90, 100,
            ],
            &[
                19, 20, 21, 22, 23, 24, 25, 26, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
                57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 90,
                100,
            ],
            &[
                19, 20, 21, 22, 23, 24, 25, 26, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
                57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
                78, 90, 100,
            ],
            &[
                19, 20, 21, 22, 23, 24, 25, 26, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
                57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
                78, 79, 80, 81, 82, 83, 84, 85, 90, 100,
            ],
            &[
                19, 20, 21, 22, 23, 24, 25, 26, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
                57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
                78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 90, 100,
            ],
            &[98, 99, 129, 130],
            &[
                19, 20, 21, 22, 23, 24, 25, 26, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,
                56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
                77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 95, 96, 97, 100,
            ],
            &[19, 20, 21, 22, 23, 24, 25, 26],
            &[
                2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 19, 20, 21, 22, 23, 24, 25, 26,
                30, 31,
            ],
            &[18, 112, 113],
            &[127, 128],
            &[121, 122, 123],
            &[38],
            &[17, 114, 115, 116, 117],
            &[17],
            &[118, 119, 120],
        ];
        const RUSTYLR_SHIFT_TERM_MAP: &[&[(u8, u8)]] = &[
            &[
                (0, 1),
                (25, 2),
                (31, 28),
                (32, 31),
                (39, 32),
                (40, 33),
                (44, 34),
                (45, 39),
                (46, 48),
                (47, 50),
                (49, 61),
                (52, 73),
                (56, 74),
            ],
            &[],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[],
            &[],
            &[],
            &[],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[
                (0, 12),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (29, 37),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(24, 13)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[],
            &[(25, 16)],
            &[(0, 17), (37, 18)],
            &[],
            &[],
            &[(34, 20)],
            &[(0, 21), (37, 22)],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[(26, 27)],
            &[
                (0, 1),
                (25, 2),
                (31, 28),
                (32, 31),
                (39, 32),
                (40, 33),
                (44, 34),
                (45, 39),
                (46, 48),
                (47, 50),
                (49, 61),
                (52, 73),
                (56, 74),
            ],
            &[(0, 29)],
            &[(31, 30)],
            &[],
            &[],
            &[],
            &[
                (0, 1),
                (25, 2),
                (31, 28),
                (32, 31),
                (39, 32),
                (40, 33),
                (44, 34),
                (45, 39),
                (46, 48),
                (47, 50),
                (49, 61),
                (52, 73),
                (56, 74),
            ],
            &[(0, 35)],
            &[(24, 36)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(0, 40)],
            &[],
            &[(33, 42), (35, 44)],
            &[(0, 43)],
            &[],
            &[(0, 45)],
            &[],
            &[(25, 16)],
            &[],
            &[(0, 49)],
            &[],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[],
            &[(1, 53), (25, 54), (27, 11), (29, 110), (33, 117), (35, 121)],
            &[],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[],
            &[],
            &[(10, 58)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
            ],
            &[(34, 60)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(0, 62), (45, 67)],
            &[(22, 63)],
            &[(0, 64)],
            &[(23, 65)],
            &[],
            &[],
            &[(0, 68)],
            &[(25, 16)],
            &[],
            &[],
            &[(24, 72), (34, 196)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[
                (0, 1),
                (25, 2),
                (31, 28),
                (32, 31),
                (39, 32),
                (40, 33),
                (44, 34),
                (45, 39),
                (46, 48),
                (47, 50),
                (49, 61),
                (52, 73),
                (56, 74),
            ],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(26, 76)],
            &[],
            &[],
            &[],
            &[(7, 80), (8, 84), (9, 86), (17, 88)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[],
            &[],
            &[],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[],
            &[(5, 91), (6, 127), (36, 129)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(26, 93)],
            &[],
            &[],
            &[],
            &[(15, 97), (16, 132)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(12, 99)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(13, 101)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(14, 103)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[
                (18, 105),
                (19, 138),
                (20, 140),
                (21, 142),
                (22, 144),
                (23, 146),
            ],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(38, 107)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(51, 109)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(32, 112), (34, 113)],
            &[],
            &[],
            &[
                (0, 12),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (29, 37),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(30, 116)],
            &[],
            &[(0, 118)],
            &[(1, 53), (25, 54), (27, 11)],
            &[],
            &[],
            &[(0, 122)],
            &[],
            &[],
            &[],
            &[],
            &[(7, 80), (8, 84), (9, 86), (17, 88)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(7, 80), (8, 84), (9, 86), (17, 88)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[],
            &[],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[],
            &[(15, 97), (16, 132)],
            &[(12, 99)],
            &[(13, 101)],
            &[(14, 103)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(14, 103)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(14, 103)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(14, 103)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(14, 103)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(14, 103)],
            &[
                (18, 105),
                (19, 138),
                (20, 140),
                (21, 142),
                (22, 144),
                (23, 146),
            ],
            &[(38, 107)],
            &[],
            &[],
            &[(28, 153)],
            &[],
            &[],
            &[(43, 156)],
            &[],
            &[],
            &[],
            &[(1, 53), (25, 54), (27, 11), (29, 110), (33, 117), (35, 121)],
            &[],
            &[(24, 162), (34, 165)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(34, 60)],
            &[],
            &[(0, 1), (25, 2)],
            &[],
            &[
                (0, 1),
                (25, 2),
                (31, 28),
                (32, 31),
                (39, 32),
                (40, 33),
                (44, 34),
                (45, 39),
                (46, 48),
                (47, 50),
                (49, 61),
                (52, 73),
                (56, 74),
            ],
            &[],
            &[(53, 170)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[],
            &[(32, 173)],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[(40, 182)],
            &[
                (0, 1),
                (25, 2),
                (31, 28),
                (32, 31),
                (39, 32),
                (40, 33),
                (44, 34),
                (45, 39),
                (46, 48),
                (47, 50),
                (49, 61),
                (52, 73),
                (56, 74),
            ],
            &[(54, 184)],
            &[
                (0, 1),
                (25, 2),
                (31, 28),
                (32, 31),
                (39, 32),
                (40, 33),
                (44, 34),
                (45, 39),
                (46, 48),
                (47, 50),
                (49, 61),
                (52, 73),
                (56, 74),
            ],
            &[(43, 186)],
            &[],
            &[(34, 188)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(34, 190)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[],
            &[],
            &[(40, 194)],
            &[
                (0, 1),
                (25, 2),
                (31, 28),
                (32, 31),
                (39, 32),
                (40, 33),
                (44, 34),
                (45, 39),
                (46, 48),
                (47, 50),
                (49, 61),
                (52, 73),
                (56, 74),
            ],
            &[(34, 60)],
            &[(0, 62)],
            &[],
            &[],
            &[],
            &[(55, 201)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[],
            &[(43, 204)],
            &[],
            &[(43, 206)],
            &[],
            &[(34, 208), (48, 209)],
            &[(0, 21)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(34, 60), (40, 211)],
            &[
                (0, 1),
                (25, 2),
                (31, 28),
                (32, 31),
                (39, 32),
                (40, 33),
                (44, 34),
                (45, 39),
                (46, 48),
                (47, 50),
                (49, 61),
                (52, 73),
                (56, 74),
            ],
            &[(43, 213)],
            &[],
            &[(42, 215)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[(54, 217)],
            &[
                (0, 1),
                (25, 2),
                (31, 28),
                (32, 31),
                (39, 32),
                (40, 33),
                (44, 34),
                (45, 39),
                (46, 48),
                (47, 50),
                (49, 61),
                (52, 73),
                (56, 74),
            ],
            &[],
            &[],
            &[(42, 215)],
            &[],
            &[(41, 223)],
            &[
                (0, 1),
                (25, 2),
                (31, 28),
                (32, 31),
                (39, 32),
                (40, 33),
                (44, 34),
                (45, 39),
                (46, 48),
                (47, 50),
                (49, 61),
                (52, 73),
                (56, 74),
            ],
            &[],
            &[],
            &[(43, 227)],
            &[],
            &[(30, 229)],
            &[(24, 230)],
            &[
                (0, 1),
                (1, 3),
                (2, 4),
                (3, 5),
                (4, 6),
                (5, 7),
                (6, 8),
                (11, 9),
                (13, 10),
                (25, 2),
                (27, 11),
                (37, 14),
                (45, 15),
                (50, 38),
            ],
            &[],
            &[],
            &[(57, 234)],
            &[],
            &[],
        ];
        const RUSTYLR_SHIFT_NONTERM_MAP: &[&[(ChunkNonTerminals, u8)]] = &[
            &[
                (ChunkNonTerminals::Block, 235),
                (ChunkNonTerminals::Chunk, 233),
                (ChunkNonTerminals::FunctionCall, 160),
                (ChunkNonTerminals::PrefixExp, 159),
                (ChunkNonTerminals::Statement, 157),
                (ChunkNonTerminals::Var, 158),
                (ChunkNonTerminals::VarList, 161),
                (ChunkNonTerminals::_Statement_Plus40, 167),
                (ChunkNonTerminals::_Statement_Star41, 169),
            ],
            &[],
            &[
                (ChunkNonTerminals::Exp, 75),
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 106),
                (ChunkNonTerminals::Exp12, 108),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 180),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 179),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 178),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 177),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[
                (ChunkNonTerminals::Exp, 56),
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 106),
                (ChunkNonTerminals::Exp12, 108),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::Field, 154),
                (ChunkNonTerminals::FieldList, 152),
                (ChunkNonTerminals::FieldList1, 111),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[
                (ChunkNonTerminals::Exp, 232),
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 106),
                (ChunkNonTerminals::Exp12, 108),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[(ChunkNonTerminals::FuncBody, 171)],
            &[
                (ChunkNonTerminals::NameList, 19),
                (ChunkNonTerminals::ParList, 25),
                (ChunkNonTerminals::_ParList_Question53, 26),
            ],
            &[],
            &[],
            &[
                (ChunkNonTerminals::_Group54, 23),
                (ChunkNonTerminals::__Group54_Question55, 24),
            ],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Block, 155),
                (ChunkNonTerminals::FunctionCall, 160),
                (ChunkNonTerminals::PrefixExp, 159),
                (ChunkNonTerminals::Statement, 157),
                (ChunkNonTerminals::Var, 158),
                (ChunkNonTerminals::VarList, 161),
                (ChunkNonTerminals::_Statement_Plus40, 167),
                (ChunkNonTerminals::_Statement_Star41, 169),
            ],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Block, 185),
                (ChunkNonTerminals::FunctionCall, 160),
                (ChunkNonTerminals::PrefixExp, 159),
                (ChunkNonTerminals::Statement, 157),
                (ChunkNonTerminals::Var, 158),
                (ChunkNonTerminals::VarList, 161),
                (ChunkNonTerminals::_Statement_Plus40, 167),
                (ChunkNonTerminals::_Statement_Star41, 169),
            ],
            &[(ChunkNonTerminals::NameList, 207)],
            &[],
            &[
                (ChunkNonTerminals::Exp, 187),
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 106),
                (ChunkNonTerminals::Exp12, 108),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[
                (ChunkNonTerminals::Exp, 228),
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 106),
                (ChunkNonTerminals::Exp12, 108),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 125),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[
                (ChunkNonTerminals::FuncName, 46),
                (ChunkNonTerminals::FuncName1, 41),
            ],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[(ChunkNonTerminals::FuncBody, 47)],
            &[],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Exp, 183),
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 106),
                (ChunkNonTerminals::Exp12, 108),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[
                (ChunkNonTerminals::Args, 123),
                (ChunkNonTerminals::TableConstructor, 120),
            ],
            &[],
            &[
                (ChunkNonTerminals::Exp, 94),
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 106),
                (ChunkNonTerminals::Exp12, 108),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::ExpList0, 92),
                (ChunkNonTerminals::ExpList1, 59),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 124),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[
                (ChunkNonTerminals::Exp, 164),
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 106),
                (ChunkNonTerminals::Exp12, 108),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[
                (ChunkNonTerminals::AttName, 70),
                (ChunkNonTerminals::AttNameList, 71),
            ],
            &[(ChunkNonTerminals::Attrib, 66)],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[(ChunkNonTerminals::FuncBody, 69)],
            &[],
            &[],
            &[
                (ChunkNonTerminals::_Group49, 198),
                (ChunkNonTerminals::__Group49_Question50, 199),
            ],
            &[
                (ChunkNonTerminals::Exp, 94),
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 106),
                (ChunkNonTerminals::Exp12, 108),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::ExpList1, 195),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[
                (ChunkNonTerminals::Block, 200),
                (ChunkNonTerminals::FunctionCall, 160),
                (ChunkNonTerminals::PrefixExp, 159),
                (ChunkNonTerminals::Statement, 157),
                (ChunkNonTerminals::Var, 158),
                (ChunkNonTerminals::VarList, 161),
                (ChunkNonTerminals::_Statement_Plus40, 167),
                (ChunkNonTerminals::_Statement_Star41, 169),
            ],
            &[
                (ChunkNonTerminals::Exp, 181),
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 106),
                (ChunkNonTerminals::Exp12, 108),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 81),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 85),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 87),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 89),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 126),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 131),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 134),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 135),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 136),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 137),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 148),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 149),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[
                (ChunkNonTerminals::Exp, 115),
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 106),
                (ChunkNonTerminals::Exp12, 108),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[
                (ChunkNonTerminals::FieldSep, 114),
                (ChunkNonTerminals::_FieldSep_Question52, 151),
            ],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Exp, 56),
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 106),
                (ChunkNonTerminals::Exp12, 108),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::Field, 150),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Args, 119),
                (ChunkNonTerminals::TableConstructor, 120),
            ],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 128),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 130),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 133),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 139),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 141),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 143),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 145),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 147),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Args, 123),
                (ChunkNonTerminals::TableConstructor, 120),
            ],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Exp, 94),
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 106),
                (ChunkNonTerminals::Exp12, 108),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::ExpList1, 163),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[],
            &[
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::PrefixExp, 159),
                (ChunkNonTerminals::Var, 166),
            ],
            &[],
            &[
                (ChunkNonTerminals::FunctionCall, 160),
                (ChunkNonTerminals::PrefixExp, 159),
                (ChunkNonTerminals::Statement, 168),
                (ChunkNonTerminals::Var, 158),
                (ChunkNonTerminals::VarList, 161),
            ],
            &[],
            &[
                (ChunkNonTerminals::ReturnStatement, 175),
                (ChunkNonTerminals::_ReturnStatement_Question42, 176),
            ],
            &[
                (ChunkNonTerminals::Exp, 94),
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 106),
                (ChunkNonTerminals::Exp12, 108),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::ExpList0, 172),
                (ChunkNonTerminals::ExpList1, 59),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[(ChunkNonTerminals::_semicolon_Question51, 174)],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Block, 203),
                (ChunkNonTerminals::FunctionCall, 160),
                (ChunkNonTerminals::PrefixExp, 159),
                (ChunkNonTerminals::Statement, 157),
                (ChunkNonTerminals::Var, 158),
                (ChunkNonTerminals::VarList, 161),
                (ChunkNonTerminals::_Statement_Plus40, 167),
                (ChunkNonTerminals::_Statement_Star41, 169),
            ],
            &[],
            &[
                (ChunkNonTerminals::Block, 214),
                (ChunkNonTerminals::FunctionCall, 160),
                (ChunkNonTerminals::PrefixExp, 159),
                (ChunkNonTerminals::Statement, 157),
                (ChunkNonTerminals::Var, 158),
                (ChunkNonTerminals::VarList, 161),
                (ChunkNonTerminals::_Statement_Plus40, 167),
                (ChunkNonTerminals::_Statement_Star41, 169),
            ],
            &[],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Exp, 189),
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 106),
                (ChunkNonTerminals::Exp12, 108),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[
                (ChunkNonTerminals::_Group47, 192),
                (ChunkNonTerminals::__Group47_Question48, 193),
            ],
            &[
                (ChunkNonTerminals::Exp, 191),
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 106),
                (ChunkNonTerminals::Exp12, 108),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Block, 205),
                (ChunkNonTerminals::FunctionCall, 160),
                (ChunkNonTerminals::PrefixExp, 159),
                (ChunkNonTerminals::Statement, 157),
                (ChunkNonTerminals::Var, 158),
                (ChunkNonTerminals::VarList, 161),
                (ChunkNonTerminals::_Statement_Plus40, 167),
                (ChunkNonTerminals::_Statement_Star41, 169),
            ],
            &[],
            &[(ChunkNonTerminals::AttName, 197)],
            &[],
            &[],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Exp, 202),
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 106),
                (ChunkNonTerminals::Exp12, 108),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Exp, 94),
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 106),
                (ChunkNonTerminals::Exp12, 108),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::ExpList1, 210),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[
                (ChunkNonTerminals::Block, 212),
                (ChunkNonTerminals::FunctionCall, 160),
                (ChunkNonTerminals::PrefixExp, 159),
                (ChunkNonTerminals::Statement, 157),
                (ChunkNonTerminals::Var, 158),
                (ChunkNonTerminals::VarList, 161),
                (ChunkNonTerminals::_Statement_Plus40, 167),
                (ChunkNonTerminals::_Statement_Star41, 169),
            ],
            &[],
            &[],
            &[
                (ChunkNonTerminals::ElseIf, 219),
                (ChunkNonTerminals::_ElseIf_Plus43, 220),
                (ChunkNonTerminals::_ElseIf_Star44, 222),
            ],
            &[
                (ChunkNonTerminals::Exp, 216),
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 106),
                (ChunkNonTerminals::Exp12, 108),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[
                (ChunkNonTerminals::Block, 218),
                (ChunkNonTerminals::FunctionCall, 160),
                (ChunkNonTerminals::PrefixExp, 159),
                (ChunkNonTerminals::Statement, 157),
                (ChunkNonTerminals::Var, 158),
                (ChunkNonTerminals::VarList, 161),
                (ChunkNonTerminals::_Statement_Plus40, 167),
                (ChunkNonTerminals::_Statement_Star41, 169),
            ],
            &[],
            &[],
            &[(ChunkNonTerminals::ElseIf, 221)],
            &[],
            &[
                (ChunkNonTerminals::_Group45, 225),
                (ChunkNonTerminals::__Group45_Question46, 226),
            ],
            &[
                (ChunkNonTerminals::Block, 224),
                (ChunkNonTerminals::FunctionCall, 160),
                (ChunkNonTerminals::PrefixExp, 159),
                (ChunkNonTerminals::Statement, 157),
                (ChunkNonTerminals::Var, 158),
                (ChunkNonTerminals::VarList, 161),
                (ChunkNonTerminals::_Statement_Plus40, 167),
                (ChunkNonTerminals::_Statement_Star41, 169),
            ],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[],
            &[
                (ChunkNonTerminals::Exp, 231),
                (ChunkNonTerminals::Exp0, 57),
                (ChunkNonTerminals::Exp1, 77),
                (ChunkNonTerminals::Exp10, 104),
                (ChunkNonTerminals::Exp11, 106),
                (ChunkNonTerminals::Exp12, 108),
                (ChunkNonTerminals::Exp2, 78),
                (ChunkNonTerminals::Exp3, 79),
                (ChunkNonTerminals::Exp4, 90),
                (ChunkNonTerminals::Exp5, 95),
                (ChunkNonTerminals::Exp6, 96),
                (ChunkNonTerminals::Exp7, 98),
                (ChunkNonTerminals::Exp8, 100),
                (ChunkNonTerminals::Exp9, 102),
                (ChunkNonTerminals::FunctionCall, 55),
                (ChunkNonTerminals::FunctionDef, 83),
                (ChunkNonTerminals::PrefixExp, 52),
                (ChunkNonTerminals::TableConstructor, 82),
                (ChunkNonTerminals::Var, 51),
            ],
            &[],
            &[],
            &[],
            &[],
            &[],
        ];
        const RUSTYLR_REDUCE_MAP: &[&[(u8, u8)]] = &[
            &[(0, 111)],
            &[(1, 19)],
            &[],
            &[(2, 46)],
            &[(2, 44)],
            &[(2, 45)],
            &[(2, 47)],
            &[],
            &[],
            &[],
            &[],
            &[(3, 94)],
            &[(4, 19)],
            &[],
            &[(2, 48)],
            &[],
            &[(5, 132)],
            &[(6, 37)],
            &[(5, 107)],
            &[(5, 135)],
            &[],
            &[(7, 36)],
            &[(5, 133)],
            &[(5, 134)],
            &[(5, 106)],
            &[(5, 131)],
            &[],
            &[(8, 111)],
            &[],
            &[],
            &[(9, 5)],
            &[(9, 2)],
            &[(9, 6)],
            &[(8, 111)],
            &[],
            &[(10, 37)],
            &[],
            &[],
            &[],
            &[],
            &[(11, 103)],
            &[(12, 105)],
            &[],
            &[(12, 104)],
            &[],
            &[(11, 102)],
            &[],
            &[(9, 14)],
            &[],
            &[(9, 7)],
            &[],
            &[(13, 22)],
            &[(14, 50)],
            &[(13, 29)],
            &[(5, 35)],
            &[(13, 23)],
            &[(15, 97)],
            &[(16, 53)],
            &[],
            &[(17, 34)],
            &[],
            &[],
            &[(18, 42)],
            &[],
            &[],
            &[(18, 41)],
            &[(18, 38)],
            &[],
            &[],
            &[(9, 15)],
            &[(18, 40)],
            &[(9, 126)],
            &[],
            &[(19, 111)],
            &[],
            &[],
            &[(13, 24)],
            &[(16, 59)],
            &[(16, 64)],
            &[(20, 67)],
            &[],
            &[(16, 60)],
            &[(2, 51)],
            &[(2, 49)],
            &[],
            &[(16, 61)],
            &[],
            &[(16, 63)],
            &[],
            &[(16, 62)],
            &[(21, 69)],
            &[],
            &[],
            &[(13, 27)],
            &[(22, 33)],
            &[(21, 72)],
            &[(23, 74)],
            &[],
            &[(24, 76)],
            &[],
            &[(25, 78)],
            &[],
            &[(26, 85)],
            &[],
            &[(27, 87)],
            &[],
            &[(28, 89)],
            &[],
            &[(29, 43)],
            &[],
            &[],
            &[(3, 130)],
            &[(30, 99)],
            &[(30, 98)],
            &[(3, 129)],
            &[],
            &[(1, 20)],
            &[],
            &[],
            &[(13, 26)],
            &[(13, 28)],
            &[],
            &[(1, 21)],
            &[(13, 25)],
            &[(16, 52)],
            &[(16, 54)],
            &[(20, 65)],
            &[],
            &[(20, 66)],
            &[],
            &[(21, 68)],
            &[(21, 70)],
            &[],
            &[(21, 71)],
            &[(23, 73)],
            &[(24, 75)],
            &[(25, 77)],
            &[(26, 84)],
            &[],
            &[(26, 83)],
            &[],
            &[(26, 80)],
            &[],
            &[(26, 82)],
            &[],
            &[(26, 79)],
            &[],
            &[(26, 81)],
            &[(27, 86)],
            &[(28, 88)],
            &[(15, 91)],
            &[(3, 93)],
            &[],
            &[(13, 90)],
            &[(15, 92)],
            &[],
            &[(2, 101)],
            &[(9, 108)],
            &[(31, 22), (32, 31)],
            &[],
            &[(9, 4), (31, 23)],
            &[],
            &[],
            &[(9, 3)],
            &[(22, 32)],
            &[],
            &[(31, 22), (32, 30)],
            &[(33, 110)],
            &[(9, 109)],
            &[(34, 113)],
            &[(35, 35)],
            &[(2, 100)],
            &[(34, 128)],
            &[(34, 127)],
            &[(34, 18)],
            &[(34, 112)],
            &[(34, 1)],
            &[(16, 58)],
            &[(16, 55)],
            &[(16, 56)],
            &[(16, 57)],
            &[],
            &[(8, 111)],
            &[],
            &[(36, 111)],
            &[],
            &[(9, 8)],
            &[],
            &[],
            &[(37, 123)],
            &[],
            &[(37, 121)],
            &[(37, 122)],
            &[],
            &[(8, 111)],
            &[(9, 124)],
            &[],
            &[(18, 39)],
            &[(9, 125)],
            &[(9, 16)],
            &[],
            &[],
            &[(9, 10)],
            &[],
            &[(9, 9)],
            &[],
            &[(9, 12)],
            &[],
            &[],
            &[],
            &[],
            &[(8, 111)],
            &[],
            &[(9, 13)],
            &[(38, 117)],
            &[],
            &[],
            &[(36, 111)],
            &[(39, 17)],
            &[(39, 114)],
            &[(38, 116)],
            &[(39, 115)],
            &[(40, 120)],
            &[(8, 111)],
            &[(40, 118)],
            &[(40, 119)],
            &[],
            &[(9, 11)],
            &[],
            &[],
            &[],
            &[(15, 95)],
            &[(15, 96)],
            &[],
            &[],
            &[(41, 0)],
        ];
        const RUSTYLR_RULESET_MAP: &[&[(u8, u8)]] = &[
            &[],
            &[(19, 1)],
            &[(24, 1)],
            &[(46, 1)],
            &[(44, 1)],
            &[(45, 1)],
            &[(47, 1)],
            &[(57, 1)],
            &[(56, 1)],
            &[(55, 1)],
            &[(58, 1)],
            &[(90, 1)],
            &[(19, 1), (96, 1)],
            &[(96, 2)],
            &[(48, 1)],
            &[(100, 1)],
            &[(101, 1)],
            &[(37, 1)],
            &[(107, 1)],
            &[(36, 1), (106, 1)],
            &[(36, 2), (133, 1)],
            &[(36, 3)],
            &[(133, 2)],
            &[(134, 1)],
            &[(106, 2)],
            &[(131, 1)],
            &[(101, 2)],
            &[(101, 3)],
            &[(5, 1)],
            &[(5, 2)],
            &[(5, 3)],
            &[(2, 1)],
            &[(6, 1)],
            &[(8, 1)],
            &[(12, 1), (13, 1)],
            &[(12, 2), (37, 1)],
            &[(12, 3)],
            &[(95, 1)],
            &[(54, 1)],
            &[(14, 1)],
            &[(103, 1)],
            &[(102, 1), (104, 1), (105, 1)],
            &[(104, 2)],
            &[(104, 3)],
            &[(102, 2)],
            &[(102, 3)],
            &[(14, 2)],
            &[(14, 3)],
            &[(7, 1)],
            &[(7, 2)],
            &[(11, 1)],
            &[(22, 1)],
            &[(20, 1), (21, 1), (25, 1), (26, 1), (50, 1)],
            &[(29, 1)],
            &[(27, 1)],
            &[(23, 1)],
            &[(97, 1)],
            &[(52, 1), (53, 1)],
            &[(52, 2)],
            &[(32, 1), (34, 1)],
            &[(32, 2)],
            &[(15, 1), (16, 1)],
            &[(38, 1)],
            &[(41, 1)],
            &[(41, 2)],
            &[(41, 3)],
            &[(38, 2)],
            &[(15, 2)],
            &[(15, 3)],
            &[(15, 4)],
            &[(40, 1)],
            &[(16, 2), (39, 1)],
            &[(124, 1)],
            &[(10, 1)],
            &[(9, 1)],
            &[(24, 2)],
            &[(24, 3)],
            &[(59, 1)],
            &[(64, 1)],
            &[(60, 1), (61, 1), (62, 1), (63, 1), (67, 1)],
            &[(60, 2)],
            &[(60, 3)],
            &[(51, 1)],
            &[(49, 1)],
            &[(61, 2)],
            &[(61, 3)],
            &[(63, 2)],
            &[(63, 3)],
            &[(62, 2)],
            &[(62, 3)],
            &[(65, 1), (66, 1), (68, 1), (69, 1)],
            &[(65, 2)],
            &[(27, 2)],
            &[(27, 3)],
            &[(33, 1)],
            &[(72, 1)],
            &[(70, 1), (71, 1), (74, 1)],
            &[(70, 2)],
            &[(73, 1), (76, 1)],
            &[(73, 2)],
            &[(75, 1), (78, 1)],
            &[(75, 2)],
            &[(77, 1), (85, 1)],
            &[(77, 2)],
            &[
                (79, 1),
                (80, 1),
                (81, 1),
                (82, 1),
                (83, 1),
                (84, 1),
                (87, 1),
            ],
            &[(84, 2)],
            &[(86, 1), (89, 1)],
            &[(86, 2)],
            &[(43, 1), (88, 1)],
            &[(88, 2)],
            &[(20, 2)],
            &[(91, 1), (93, 1)],
            &[(99, 1)],
            &[(98, 1)],
            &[(91, 2), (129, 1)],
            &[(20, 3)],
            &[(20, 4)],
            &[(26, 2)],
            &[(26, 3)],
            &[(26, 4)],
            &[(28, 1)],
            &[(21, 2)],
            &[(21, 3)],
            &[(25, 2)],
            &[(52, 3)],
            &[(54, 2)],
            &[(60, 1), (61, 1), (62, 1), (63, 1), (65, 3)],
            &[(66, 2)],
            &[(60, 1), (61, 1), (62, 1), (63, 1), (66, 3)],
            &[(68, 2)],
            &[(68, 3)],
            &[(70, 3)],
            &[(71, 2)],
            &[(71, 3)],
            &[(70, 1), (71, 1), (73, 3)],
            &[(73, 1), (75, 3)],
            &[(75, 1), (77, 3)],
            &[(77, 1), (84, 3)],
            &[(83, 2)],
            &[(77, 1), (83, 3)],
            &[(80, 2)],
            &[(77, 1), (80, 3)],
            &[(82, 2)],
            &[(77, 1), (82, 3)],
            &[(79, 2)],
            &[(77, 1), (79, 3)],
            &[(81, 2)],
            &[(77, 1), (81, 3)],
            &[
                (79, 1),
                (80, 1),
                (81, 1),
                (82, 1),
                (83, 1),
                (84, 1),
                (86, 3),
            ],
            &[(86, 1), (88, 3)],
            &[(91, 3)],
            &[(93, 2)],
            &[(90, 2)],
            &[(90, 3)],
            &[(92, 1)],
            &[(101, 4)],
            &[(101, 5)],
            &[(108, 1)],
            &[(22, 1), (31, 1)],
            &[(20, 1), (21, 1), (25, 1), (26, 1)],
            &[(4, 1), (23, 1)],
            &[(3, 1), (30, 1)],
            &[(3, 2)],
            &[(3, 3), (32, 1)],
            &[(32, 3)],
            &[(30, 2)],
            &[(22, 1), (30, 3)],
            &[(109, 1), (110, 1)],
            &[(109, 2)],
            &[(1, 1)],
            &[(18, 1)],
            &[(100, 2)],
            &[(18, 2)],
            &[(127, 1)],
            &[(18, 3)],
            &[(112, 1)],
            &[(1, 2)],
            &[(58, 2)],
            &[(55, 2)],
            &[(56, 2)],
            &[(57, 2)],
            &[(9, 2)],
            &[(9, 3)],
            &[(11, 2)],
            &[(11, 3)],
            &[(8, 2)],
            &[(8, 3)],
            &[(12, 4)],
            &[(12, 5)],
            &[(12, 6)],
            &[(121, 1)],
            &[(121, 2)],
            &[(122, 1)],
            &[(12, 7)],
            &[(12, 8)],
            &[(32, 1), (124, 2)],
            &[(39, 2)],
            &[(39, 3)],
            &[(125, 1)],
            &[(16, 3)],
            &[(10, 2)],
            &[(10, 3)],
            &[(10, 4)],
            &[(9, 4)],
            &[(9, 5)],
            &[(12, 9)],
            &[(12, 10)],
            &[(13, 2), (36, 1)],
            &[(36, 2)],
            &[(13, 3)],
            &[(13, 4), (32, 1)],
            &[(13, 5)],
            &[(13, 6)],
            &[(13, 7)],
            &[(11, 4)],
            &[(17, 1)],
            &[(17, 2)],
            &[(17, 3)],
            &[(17, 4)],
            &[(114, 1)],
            &[(115, 1), (116, 1)],
            &[(115, 2)],
            &[(11, 5)],
            &[(118, 1)],
            &[(118, 2)],
            &[(119, 1)],
            &[(11, 6)],
            &[(11, 7)],
            &[(95, 2)],
            &[(95, 3)],
            &[(95, 4)],
            &[(95, 5)],
            &[(96, 3)],
            &[(136, 1)],
            &[(136, 2)],
            &[(0, 1)],
        ];
        const RUSTYLR_RULESET_SHIFTED0_MAP: &[u8] = &[
            0, 1, 2, 1, 1, 1, 1, 3, 3, 3, 3, 4, 1, 2, 1, 5, 6, 1, 1, 7, 1, 1, 1, 1, 1, 1, 1, 8, 1,
            1, 1, 1, 1, 8, 9, 1, 2, 2, 3, 10, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 2, 1, 11, 1, 12, 1, 1,
            1, 13, 1, 2, 14, 15, 1, 1, 1, 1, 1, 5, 1, 1, 16, 17, 8, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1,
            3, 1, 3, 1, 3, 1, 1, 18, 1, 1, 1, 1, 1, 19, 1, 20, 1, 21, 1, 22, 1, 23, 1, 24, 1, 25,
            2, 26, 1, 1, 27, 1, 1, 1, 11, 1, 1, 1, 1, 1, 1, 1, 1, 18, 1, 19, 1, 1, 19, 1, 1, 1, 1,
            1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 1, 1, 17, 1,
            1, 28, 1, 29, 1, 30, 12, 1, 31, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 8, 1, 1, 1, 2, 32, 2,
            1, 1, 1, 8, 1, 33, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 17, 1, 8, 1, 1, 34, 2, 1, 8, 1,
            1, 35, 1, 36, 8, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1,
        ];
        let states: Vec<ChunkState> = RUSTYLR_SHIFT_TERM_MAP
            .iter()
            .zip(
                RUSTYLR_SHIFT_NONTERM_MAP.iter().zip(
                    RUSTYLR_REDUCE_MAP.iter().zip(
                        RUSTYLR_RULESET_MAP
                            .iter()
                            .zip(RUSTYLR_RULESET_SHIFTED0_MAP.iter()),
                    ),
                ),
            )
            .map(
                |(
                    shift_goto_map_term,
                    (shift_goto_map_nonterm, (reduce_map_, (ruleset, ruleset0_id))),
                )| {
                    let mut reduce_map = ::rusty_lr::HashMap::default();
                    for (terminal_set_id, ruleid) in reduce_map_.iter() {
                        for term in RUSTYLR_REDUCE_TERMINALS_CACHE[*terminal_set_id as usize].iter()
                        {
                            reduce_map
                                .entry(__rustylr_terminals[*term as usize].clone())
                                .or_insert_with(Vec::new)
                                .push(*ruleid as usize);
                        }
                    }
                    let mut ruleset: Vec<::rusty_lr::ShiftedRuleRef> = ruleset
                        .iter()
                        .map(|(ruleid, shifted)| ::rusty_lr::ShiftedRuleRef {
                            rule: *ruleid as usize,
                            shifted: *shifted as usize,
                        })
                        .collect();
                    ruleset.extend(
                        RUSTYLR_RULESET_SHIFTED0_CACHE[*ruleset0_id as usize]
                            .iter()
                            .map(|ruleid| ::rusty_lr::ShiftedRuleRef {
                                rule: *ruleid as usize,
                                shifted: 0,
                            }),
                    );
                    ChunkState {
                        shift_goto_map_term: shift_goto_map_term
                            .iter()
                            .map(|(term_idx, goto)| {
                                (
                                    __rustylr_terminals[*term_idx as usize].clone(),
                                    *goto as usize,
                                )
                            })
                            .collect(),
                        shift_goto_map_nonterm: shift_goto_map_nonterm
                            .iter()
                            .map(|(nonterm, goto)| (*nonterm, *goto as usize))
                            .collect(),
                        reduce_map,
                        ruleset,
                    }
                },
            )
            .collect();
        Self { rules, states }
    }
}
// ==============================Generated Codes End===============================
